<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法刷题-数组基础day1</title>
      <link href="/2024/03/20/suan-fa-shua-ti-shu-zu-ji-chu-day1/"/>
      <url>/2024/03/20/suan-fa-shua-ti-shu-zu-ji-chu-day1/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem-704-二分查找"><a href="#Problem-704-二分查找" class="headerlink" title="Problem: 704. 二分查找"></a>Problem: <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>二分查找，重点是边界的判断</p></blockquote><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><ol><li>第一种写法：左闭右闭区间 <code>[left, right]</code></li></ol><ul><li><p>区间定义：目标值 <code>target</code> 在区间 <code>[left, right]</code> 内。</p></li><li><p>关键点：</p><ul><li><p>循环条件：使用 <code>while (left &lt;= right)</code>，因为当 <code>left == right</code> 时，中间元素 <code>nums[middle]</code> 可能就是目标值，所以需要检查。</p></li><li><p>边界更新：</p><ul><li>如果 <code>nums[middle] &gt; target</code>，则更新 <code>right = middle - 1</code>，因为当前 <code>nums[middle]</code>不是目标值，且由于区间是左闭右闭的，所以 <code>middle</code> 不应包含在下一轮搜索的右区间中。</li><li>如果 <code>nums[middle] &lt; target</code>，则更新 <code>left = middle + 1</code>，因为当前 <code>nums[middle]</code> 不是目标值，且下一轮搜索的左区间应从 middle 的下一个位置开始。</li></ul></li></ul></li></ul><ol start="2"><li>第二种写法：左闭右开区间 <code>[left, right)</code></li></ol><ul><li><p>区间定义：目标值 <code>target</code> 在区间 <code>[left, right)</code> 内。</p></li><li><p>关键点：</p><ul><li><p>循环条件：使用 <code>while (left &lt; right)</code>，因为当 <code>left == right</code> 时，区间 <code>[left, right)</code> 内没有元素，所以不需要检查。</p></li><li><p>边界更新：</p><ul><li>如果 <code>nums[middle] &gt; target</code>，则更新 <code>right = middle</code>，因为当前 <code>nums[middle]</code> 不是目标值，且由于区间是左闭右开的，所以<code>middle</code> 不应包含在下一轮搜索的右区间中。</li><li>如果 <code>nums[middle] &lt; target</code>，则更新 <code>left = middle + 1</code>，与第一种写法相同，因为 <code>middle</code> 也不应包含在下一轮搜索的左区间中。</li></ul></li></ul></li></ul><p><strong>注意事项</strong><br>在二分查找中，<code>middle</code> 的计算通常使用 <code>int middle = left+(right - left) / 2</code>;<br>而不是 <code>int middle = (left + right) / 2</code>;<br>这是为了避免当 <code>left</code> 和 <code>right</code>都很大时，它们的和可能会导致整数溢出。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:</p><blockquote><p>O(log n)</p></blockquote><p>空间复杂度:</p><blockquote><p>O(1)</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右闭区间 [left, right]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r){</span><br><span class="line">            <span class="type">int</span> mid=(r+l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> num=nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(num==target){</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;target){</span><br><span class="line">                r=mid-<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右开区间 [left, right)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">      <span class="type">int</span> l=<span class="number">0</span>,r=nums.length;</span><br><span class="line">      <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">        <span class="type">int</span> mid=(r+l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]){</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]){</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">           r=mid;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Problem-27-移除元素"><a href="#Problem-27-移除元素" class="headerlink" title="Problem: 27. 移除元素"></a>Problem: <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote><p>双指针法</p></blockquote><h2 id="解题方法-1"><a href="#解题方法-1" class="headerlink" title="解题方法"></a>解题方法</h2><ul><li>具体来说，我们使用两个指针<code>l</code>和<code>r</code>，它们都从数组的开始位置（索引为<code>0</code>）开始。其中，<code>l</code>指针用于指向下一个非<code>val</code>元素应该存放的位置，而<code>r</code>指针用于遍历整个数组。</li><li>在遍历过程中，如果<code>nums[r]</code>不等于<code>val</code>，说明当前元素是需要保留的，那么我们就把它放到<code>l</code>指针所指向的位置，并且<code>l</code>指针向前移动一位，以指向下一个非<code>val</code>元素应该存放的位置。如果<code>nums[r]</code>等于<code>val</code>，那么我们就跳过这个元素，<code>l</code>指针不动，只让<code>r</code>指针继续向前遍历。</li><li>遍历完成后，<code>l</code>指针所指向的位置就是数组中最后一个非<code>val</code>元素的下一个位置，也就是移除<code>val</code>元素后数组的新长度。因此，我们返回<code>l</code>作为结果。</li></ul><p><strong>总结</strong>： 在这个算法中，<code>l</code>和<code>r</code>指针初始时都指向数组的第一个元素。随着遍历的进行，<code>r</code>指针可能会走得比<code>l</code>指针快，因为当遇到值为<code>val</code>的元素时，<code>r</code>指针会继续向前移动，而<code>l</code>指针则保持不变。当遍历结束时，<code>l</code>指针指向的就是新数组（移除<code>val</code>后）的末尾位置。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:</p><blockquote><p>O(n)</p></blockquote><p>空间复杂度:</p><blockquote><p>O(1)</p></blockquote><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> {</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;nums.length;r++){</span><br><span class="line">                <span class="keyword">if</span>(nums[r]!=val){</span><br><span class="line">                    nums[l]=nums[r];</span><br><span class="line">                    l++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之系统调用</title>
      <link href="/2024/03/19/cao-zuo-xi-tong-zhi-xi-tong-diao-yong/"/>
      <url>/2024/03/19/cao-zuo-xi-tong-zhi-xi-tong-diao-yong/</url>
      
        <content type="html"><![CDATA[<p>我们可以通过命令行来使用到操作系统提供的功能，那么输入一个命令行后发生了什么？下面举一个实际的<strong>例子</strong>来说明：</p><p><strong>有关操作</strong>：<br>你编写了一个<code>output.c</code>文件，该程序内容如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ECHO:%s\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后，你在命令行输入<code>gcc -o output output.c</code></p><blockquote><p>这条命令的意思是：使用 GCC 编译器编译 output.c文件，并将编译后的可执行文件命名为 output</p></blockquote><p><strong>这时</strong>，在命令行输入 <code>./output "hello"</code><br>得到结果： <code>ECHO:hello</code></p><p>那么输入一个命令行后发生了什么才得到我们想要的<strong>结果</strong>了呢？</p><p><strong>首先</strong>，说明<strong>命令的含义</strong>：就是一段程序。<br>程序要编译，程序编译完后生成可执行文件，刚才我们已经说明。</p><p><code>./ouput</code>运行可执行文件，那么<code>“hello”</code>究竟是怎么读到的呢？<br>这就是<code>shell</code>所做的工作，<code>shell</code>的本质也是一段程序，关键代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char * argv[])</span><br><span class="line">{</span><br><span class="line">    char cmd[20];</span><br><span class="line">    while(1){</span><br><span class="line">        scanf("%s",cmd);</span><br><span class="line">        if(!fork()){exec(cmd);}</span><br><span class="line">        else wait();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>关键代码说明</strong><br><code>if (!fork())</code>：调用 <code>fork()</code> 函数创建一个子进程。<code>fork()</code> 返回一个正整数（父进程的PID）给父进程，返回0给子进程。因此，<code>!fork()</code> 的条件只在子进程中为真。</p><p><code>exec(cmd)</code>：在子进程中，调用 <code>exec</code> 函数来执行用户输入的命令。</p><p><code>else wait()</code>：在父进程中，调用 <code>wait()</code> 函数等待子进程结束。<code>wait()</code> 会阻塞父进程，直到任意一个子进程结束。</p><p>那么什么是<strong>操作系统接口</strong>呢？</p><p>就是函数，比如刚才的<code>printf</code>，而<code>printf</code>包装了一个系统调用<code>write()</code>。</p><p>所以说接口表现为函数调用，又由系统提供，所以称为系统调用,即<code>System_call</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 系统调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之SpringCloud</title>
      <link href="/2024/03/18/wei-fu-wu-zhi-springcloud/"/>
      <url>/2024/03/18/wei-fu-wu-zhi-springcloud/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><code>Spring Cloud Alibaba</code> 是阿里开源的一套微服务开发组件，致力于提供微服务开发的一站式解决方案，核心组件有下面这些：</p><ul><li><code>Sentinel</code>：以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>Nacos</code>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Seata</code>：分布式事务解决方案。</li><li><code>OpenFeign</code>：轻量级 RESTful 的 HTTP 服务客户端，用于替代已经进入停更维护状态的 Feign（Netflix Feign）</li><li><code>Gateway</code>：用于网关服务，实现请求的转发和路由。</li><li><code>Ribbon</code>：用于客户端负载均衡，将请求分发给不同的微服务实例。</li></ul><h3 id="2-实践选择："><a href="#2-实践选择：" class="headerlink" title="2.实践选择："></a>2.实践选择：</h3><p>本次实践选用的组件如下：</p><ul><li><code>Eureka</code> 实现服务注册与发现(<code>Netflix</code>)</li><li><code>Gateway</code> 实现 <code>API</code> 网关</li><li><code>Ribbon</code> 实现负载均衡（<code>Feign</code> 内置）</li><li><code>Feign</code> 实现基于 <code>Feign</code> 的服务调用</li><li><code>Hystrix</code> 实现服务熔断（<code>Feign</code> 内置）</li><li><code>Config</code> 实现 <code>Config</code> 配置中心</li></ul><p>&lt;picture项目逻辑架构&gt;</p><h3 id="3-SpringCloud-聚合项目的创建"><a href="#3-SpringCloud-聚合项目的创建" class="headerlink" title="3.SpringCloud 聚合项目的创建"></a>3.SpringCloud 聚合项目的创建</h3><h4 id="3-1聚合项目及其作用"><a href="#3-1聚合项目及其作用" class="headerlink" title="3.1聚合项目及其作用"></a>3.1聚合项目及其作用</h4><ol><li>创建聚合项目的目的:</li></ol><ul><li>更好地管理和组织多个相关联的项目，可以统一管理它们的<strong>依赖关系</strong>，统一<strong>打包发布</strong>，方便项目的构建和部署。</li><li>聚合项目也可以提高团队协作效率，统一管理项目的<strong>版本和发布流程</strong>。</li><li>聚合项目还可以方便地进行跨项目的<strong>代码重用和共享</strong>，提高代码的<strong>复用性和可维护性</strong>。</li></ul><h4 id="3-2-聚合项目（父级项目、顶级项目）的Maven配置说明"><a href="#3-2-聚合项目（父级项目、顶级项目）的Maven配置说明" class="headerlink" title="3.2 聚合项目（父级项目、顶级项目）的Maven配置说明"></a>3.2 聚合项目（父级项目、顶级项目）的Maven配置说明</h4><p><strong>聚合项目特性</strong></p><p>聚合项目本身也是一个Maven项目，其核心在于管理和协调多个子模块。这样的设计有助于消除子模块POM中的重复配置，提升项目的可维护性。</p><p><strong>关键配置要点</strong></p><ol><li><strong>POM文件</strong>：聚合项目必须有自己的<code>pom.xml</code>文件。</li><li><strong>打包方式</strong>：聚合项目的打包方式必须是<code>pom</code>，因为它不包含任何实际代码。</li><li><strong>目录结构</strong>：聚合模块仅包含<code>pom.xml</code>文件，不包含<code>src/main/java</code>和<code>src/test/java</code>等目录。</li></ol><p><strong>引入新元素</strong></p><ul><li><strong>modules-module</strong>：用于声明聚合的子模块，每个子模块都是一个独立的项目。</li></ul><p><strong>版本一致性</strong></p><ul><li>聚合模块的版本应与被聚合的子模块版本保持一致，以确保依赖关系的一致性。</li></ul><p><strong>路径配置</strong></p><ul><li><strong>relative path</strong>：每个子模块的名称都应是当前POM文件的相对目录。</li></ul><p><strong>目录命名约定</strong></p><ul><li>为了方便定位，建议模块所在的目录与其<code>artifactId</code>保持一致。但这不是硬性要求，重要的是模块目录必须与聚合模块中声明的模块目录相匹配。</li></ul><p><strong>目录结构选择</strong></p><ul><li>聚合模块与子模块可以是父子级结构，也可以是平行结构。推荐使用平行结构，因为它有助于保持项目结构的清晰和易于维护。如果使用平行结构，需要在POM文件中相应调整目录路径配置。</li></ul><p><strong>删除子模块注意事项</strong></p><ul><li>如果从聚合项目中删除了某个子模块，务必在聚合模块的<code>pom.xml</code>文件中的<code>modules</code>选项中删除对应的子模块声明，以避免潜在的配置错误。</li></ul><h4 id="3-3实操演练"><a href="#3-3实操演练" class="headerlink" title="3.3实操演练"></a>3.3实操演练</h4><blockquote><p> 待更新…….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/03/17/suan-fa/"/>
      <url>/2024/03/17/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS-宽度优先搜索"><a href="#BFS-宽度优先搜索" class="headerlink" title="BFS 宽度优先搜索"></a>BFS 宽度优先搜索</h1><h4 id="1-基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾"><a href="#1-基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾" class="headerlink" title="1. 基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾"></a>1. 基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾</h4><blockquote><p>理解拓展：目前做的2道题-迷宫有关，拓展的是队头的上下左右（2维迷宫）/向北、向南、向东、向西、向上、向下（3维迷宫）</p></blockquote><blockquote><p>BFS最先输出的肯定是最短路径，因为是按宽度搜索的；求最短路径的题可以想想宽搜</p></blockquote><h4 id="2-模板如下："><a href="#2-模板如下：" class="headerlink" title="2. 模板如下："></a>2. 模板如下：</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 判重数组st[]  //入队时判重</span><br><span class="line">2. queue</span><br><span class="line">    queue&lt;-初始状态</span><br><span class="line">    while(queue非空)</span><br><span class="line">    {</span><br><span class="line">        t&lt;-队头 //队头出队</span><br><span class="line">        for(拓展t)</span><br><span class="line">        {</span><br><span class="line">            v&lt;-新节点</span><br><span class="line">            if(!st[v])</span><br><span class="line">            {</span><br><span class="line">                v-&gt;队尾</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="3-具体习题"><a href="#3-具体习题" class="headerlink" title="3. 具体习题"></a>3. 具体习题</h4><h5 id="3-1-献给阿尔吉侬的花束-二维"><a href="#3-1-献给阿尔吉侬的花束-二维" class="headerlink" title="3.1 献给阿尔吉侬的花束(二维)"></a>3.1 <a href="https://www.acwing.com/problem/content/1103/">献给阿尔吉侬的花束(二维)</a></h5><p>具体代码实现如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"></span><br><span class="line">const int N = 210;</span><br><span class="line"></span><br><span class="line">char a[N][N];</span><br><span class="line">int dis[N][N];</span><br><span class="line"></span><br><span class="line">void bfs(PII start)</span><br><span class="line">{</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.push(start);//队头队，对应步骤1</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        PII u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int dx[4] = {-1, 0, 1, 0};</span><br><span class="line">        int dy[4] = {0, 1, 0 ,-1};</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)//遍历四个方向，对应步骤2</span><br><span class="line">        {</span><br><span class="line">            int x = u.first + dx[i];</span><br><span class="line">            int y = u.second + dy[i];</span><br><span class="line"></span><br><span class="line">            if(a[x][y] == '#') continue;//如果是'#',不做任何处理</span><br><span class="line">            if(a[x][y] == '.')//如果是 '.'，更新对应内容</span><br><span class="line">            {</span><br><span class="line">                dis[x][y] = dis[u.first][u.second] + 1;</span><br><span class="line">                a[x][y] = '#';</span><br><span class="line">                q.push({x, y});</span><br><span class="line">            }</span><br><span class="line">            if(a[x][y] == 'E')//如果是'E'，找到了，输出</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; dis[u.first][u.second] + 1 &lt;&lt; endl;</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; "oop!" &lt;&lt; endl;//没有找到</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t--)</span><br><span class="line">    {</span><br><span class="line">        memset(a, '#', sizeof(a));//初始化地图，各个点都是墙。</span><br><span class="line">        memset(dis, 0, sizeof(dis));//初始化dis</span><br><span class="line">        int n,m;</span><br><span class="line">        PII start;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)//从第一行存储地图，因为四周都是墙，bfs时，可以不做越界判断</span><br><span class="line">        {</span><br><span class="line">            for(int j = 1; j &lt;= m; j++)//从第一；列存储地图，因为四周都是墙，bfs时，可以不做越界判断</span><br><span class="line">            {</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                if(a[i][j] == 'S')//记录下起点位置。</span><br><span class="line">                    start.first = i, start.second = j, a[i][j] = '#';</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        bfs(start);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="3-2-地牢大师-三维"><a href="#3-2-地牢大师-三维" class="headerlink" title="3.2 地牢大师(三维)"></a>3.2 <a href="https://www.acwing.com/problem/content/1098/">地牢大师(三维)</a></h5><p>仿照刚才二维的题，给出具体代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">{</span><br><span class="line">    int x,y,z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">char m[N][N][N];//地图</span><br><span class="line">int dis[N][N][N];</span><br><span class="line">int l,r,c;</span><br><span class="line">int dx[6] = {-1, 0, 1, 0, 0, 0}, dy[6] = {0, 1, 0, -1, 0, 0}, dz[6] = {0, 0, 0, 0, 1, -1};</span><br><span class="line"></span><br><span class="line">int bfs(Point start)</span><br><span class="line">{</span><br><span class="line">    queue&lt;Point&gt; q;</span><br><span class="line">    </span><br><span class="line">    q.push(start);</span><br><span class="line">    </span><br><span class="line">    while(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        Point t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;6;i++)</span><br><span class="line">        {</span><br><span class="line">            int x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];</span><br><span class="line">            if(m[x][y][z]=='#')continue;</span><br><span class="line">            if(m[x][y][z]=='.')</span><br><span class="line">            {</span><br><span class="line">                dis[x][y][z]=dis[t.x][t.y][t.z]+1;</span><br><span class="line">                m[x][y][z]='#';</span><br><span class="line">                q.push({x,y,z});</span><br><span class="line">            }</span><br><span class="line">            if(m[x][y][z]=='E')</span><br><span class="line">            {</span><br><span class="line">                return dis[t.x][t.y][t.z]+1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    while(scanf("%d%d%d",&amp;l,&amp;r,&amp;c),l||r||c)</span><br><span class="line">    {</span><br><span class="line">        memset(m,'#',sizeof(m));</span><br><span class="line">        memset(dis,0,sizeof(dis));</span><br><span class="line">        Point start,end;</span><br><span class="line">        for(int i=1;i&lt;=l;i++)</span><br><span class="line">        {</span><br><span class="line">            for(int j=1;j&lt;=r;j++)</span><br><span class="line">            {</span><br><span class="line">                for(int k=1;k&lt;=c;k++)</span><br><span class="line">                {</span><br><span class="line">                    cin&gt;&gt;m[i][j][k];</span><br><span class="line">                    if(m[i][j][k]=='S')start={i,j,k};</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        int distance=bfs(start);</span><br><span class="line">        if(distance==-1)puts("Trapped!");</span><br><span class="line">        else printf("Escaped in %d minute(s).\n",distance);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>其实可以看出很强的规律性，这两道题的做法几乎可以一模一样；等我再做几道题找找规律</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复盘</title>
      <link href="/2024/03/15/fu-pan/"/>
      <url>/2024/03/15/fu-pan/</url>
      
        <content type="html"><![CDATA[<h3 id="2024-3-15"><a href="#2024-3-15" class="headerlink" title="2024/3/15"></a>2024/3/15</h3><blockquote><p>开学将近两周了，今天起，每日记录自己的收获，学习笔记心得啥的，多动脑多记录多实践，现在是2024/3/15 23:51，开始记录，也是对自己的检讨和复盘，即使调整学习状态吧</p></blockquote><p><strong>今日收获</strong></p><ol><li><code>leetcode</code>刷了7道题</li><li>八股计网看完了，操作系统看了一半</li></ol><p><code>今天没学太多，上午起来后就去上课了，晚上开始就一直焦虑摆烂刷帖子，有效学习就在下午，满打满算也就学了3个小时。</code><br><code>又开始焦虑了，总是认为只能兼顾一头，实际上时间是很够的，多学习多思考，我的学习能力不差的，焦虑的时候不看帖子群聊啥的了，专注提升自己的技术吧，多多实践</code></p><p><code>加油</code></p><h3 id="2024-3-17"><a href="#2024-3-17" class="headerlink" title="2024/3/17"></a>2024/3/17</h3><p><strong>今日收获</strong></p><ol><li>双指针算法，`BFS算法，图论算法各一题，找时间写博客总结</li><li>数学学习，多背背结论，这是为了站在高起点</li><li><code>SpringCloud</code>学习，搭建基础项目结构</li></ol><blockquote><p>调整为周计划待办的方式记录学习</p></blockquote><h3 id="2024-3-18"><a href="#2024-3-18" class="headerlink" title="2024/3/18"></a>2024/3/18</h3><p><strong>本周待办</strong></p><ol><li>70道leetcode</li><li>八股 保质</li><li>OS实验</li><li>高数一元微分学</li><li>每日单词</li><li>微服务项目，不确定难度，这周摸索一下，不要求做的太多</li><li>…</li></ol>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心灵对话 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
