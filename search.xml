<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法刷题-哈希表day6</title>
      <link href="/2024/03/26/suan-fa-shua-ti-ha-xi-biao-day6/"/>
      <url>/2024/03/26/suan-fa-shua-ti-ha-xi-biao-day6/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem-454-四数相加-II"><a href="#Problem-454-四数相加-II" class="headerlink" title="Problem: 454. 四数相加 II"></a>Problem: <a href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加 II</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>核心思想是，利用HashMap数据结构快速查询和存储组合数出现的次数，进而快速得到四数之和为0的组合数。</p><p>具体思路如下：</p><ol><li><p><strong>初始化HashMap</strong>：<br>首先，创建一个HashMap，其键是两个元素之和，值是这个和出现的次数。</p></li><li><p><strong>计算nums1和nums2的两数之和</strong>：<br>对于nums1中的每一个元素i，遍历nums2中的每一个元素j，计算i和j的和，并更新HashMap中对应键（即i+j的和）的值。如果i+j的和已经存在于HashMap中，那么其值（即出现的次数）加1；如果i+j的和不在HashMap中，那么将其添加到HashMap中，并设置其值为1。</p><p>这样，遍历结束后，HashMap中存储了nums1和nums2中所有可能的两数之和及其出现的次数。</p></li><li><p><strong>计算nums3和nums4的两数之和，并与HashMap中的值进行匹配</strong>：<br>接下来，对于nums3中的每一个元素i，遍历nums4中的每一个元素j，计算-i-j的和（这里取负是为了找到能与nums1和nums2中的某两个数之和抵消的数）。然后，查看HashMap中是否存在这个和（即检查HashMap的键是否为-i-j）。</p><p>如果存在，说明nums1和nums2中存在两个数，它们的和与nums3中的i和nums4中的j的和的相反数相等，即这四个数的和为0。因此，将HashMap中对应键的值（即出现的次数）加到结果res中。</p><p>遍历结束后，res的值就是所有四数之和为0的组合数。</p></li><li><p><strong>返回结果</strong>：<br>最后，返回res作为结果。</p></li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> {</span><br><span class="line">        <span class="comment">//&lt;两个元素之和，出现的次数&gt;</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums1){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums2){</span><br><span class="line">                map.put(i+j,map.getOrDefault(i+j,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums3){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums4){</span><br><span class="line">                res+=map.getOrDefault(-i-j,<span class="number">0</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-383-赎金信"><a href="#Problem-383-赎金信" class="headerlink" title="Problem: 383. 赎金信"></a>Problem: <a href="https://leetcode.cn/problems/ransom-note/description/">383. 赎金信</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>判断一份“赎金信”（ransomNote）是否可以通过剪切杂志（magazine）中的字符来构造。<br>思路是，首先统计杂志中每个字符出现的次数，然后逐个检查赎金信中的字符是否在杂志中出现，并且出现的次数是否足够。</p><p>以下是具体的思路步骤：</p><ol><li><p><strong>初始化HashMap</strong>：<br>创建一个HashMap，键是字符，值是该字符在杂志中出现的次数。</p></li><li><p><strong>统计杂志中字符的出现次数</strong>：<br>遍历杂志（magazine）字符串中的每一个字符，对于每个字符，检查它是否已经在HashMap中。如果在，则将其对应的值（即出现次数）加1；如果不在，则将其添加到HashMap中，并设置其值为1。这样，当遍历结束时，HashMap中就存储了杂志中所有字符及其出现的次数。</p></li><li><p><strong>检查赎金信中的字符</strong>：<br>遍历赎金信（ransomNote）字符串中的每一个字符，对于每个字符，检查它是否在HashMap的键中。</p><ul><li>如果在，说明这个字符在杂志中有出现，那么将其在HashMap中对应的值（即出现次数）减1。</li><li>如果不在，或者该字符在杂志中的出现次数已经为0（即减1后变为负数），则说明杂志中的字符不足以构造赎金信，直接返回false。</li></ul></li><li><p><strong>返回结果</strong>：<br>如果赎金信中的所有字符都在杂志中出现，并且出现的次数都足够，那么在遍历结束后，代码会执行到返回true的语句。否则，在遍历过程中会因为找不到字符或字符数量不足而返回false。</p></li></ol><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> {</span><br><span class="line">       <span class="comment">//&lt;赎金信上的字母，出现的次数&gt;</span></span><br><span class="line">       Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;magazine.length();i++){</span><br><span class="line">        map.put(magazine.charAt(i),map.getOrDefault(magazine.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ransomNote.length();i++){</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(ransomNote.charAt(i))){</span><br><span class="line">            map.put(ransomNote.charAt(i),map.get(ransomNote.charAt(i))-<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(ransomNote.charAt(i))||map.get(ransomNote.charAt(i))&lt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-15-三数之和"><a href="#Problem-15-三数之和" class="headerlink" title="Problem: 15. 三数之和"></a>Problem: <a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>核心思路是首先对数组进行排序，然后使用三个指针来遍历数组，找出所有不重复的三元组，使得这三个数的和为0。</p><p>具体思路如下：</p><ol><li><p><strong>初始化结果列表</strong>：<br>首先，创建一个空的ArrayList <code>res</code>，用于存储结果。</p></li><li><p><strong>对数组进行排序</strong>：<br>使用<code>Arrays.sort(nums)</code>对输入的整数数组<code>nums</code>进行排序。排序是解决这个问题的关键步骤，因为排序后，我们可以利用有序数组的特性来减少不必要的遍历。</p></li><li><p><strong>遍历数组</strong>：<br>使用指针<code>i</code>从数组的第一个元素开始遍历。在遍历过程中，需要注意以下情况：</p><ul><li>如果<code>nums[i]</code>大于0，由于数组已排序，因此后续的所有元素都大于0，不可能再找到三个数之和为0的情况，所以直接返回结果列表。</li><li>如果<code>i</code>不是数组的第一个元素，并且<code>nums[i]</code>与前一个元素<code>nums[i-1]</code>相同，则跳过此次循环，避免重复。</li></ul></li><li><p><strong>使用双指针寻找另外两个数</strong>：<br>对于每个<code>nums[i]</code>，使用双指针<code>left</code>和<code>right</code>分别指向<code>i</code>的下一个位置和数组末尾。双指针的作用是在已排序的数组中找到两个数，使得与<code>nums[i]</code>的和为0。</p><ul><li>当<code>left &lt; right</code>时，计算当前三个数的和<code>sum</code>。<ul><li>如果<code>sum</code>等于0，则找到了一个符合要求的三元组，将其添加到结果列表中，并移动<code>left</code>和<code>right</code>指针，跳过重复的元素，以避免结果重复。</li><li>如果<code>sum</code>大于0，说明当前的和偏大，需要减小和，因此将<code>right</code>指针左移。</li><li>如果<code>sum</code>小于0，说明当前的和偏小，需要增大和，因此将<code>left</code>指针右移。</li></ul></li></ul></li><li><p><strong>返回结果</strong>：<br>当遍历完所有可能的<code>nums[i]</code>后，返回结果列表<code>res</code>。</p></li></ol><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n^2)，其中n是数组的长度。因为排序的复杂度是O(n log n)，而遍历数组和双指针的复杂度是O(n^2)</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++){</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> left=i+<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">            <span class="type">int</span> sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>){</span><br><span class="line">                res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>])right--;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                right--;</span><br><span class="line">                left++;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>){</span><br><span class="line">                right--;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>){</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-18-四数之和"><a href="#Problem-18-四数之和" class="headerlink" title="Problem: 18. 四数之和"></a>Problem: <a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和</a></h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>就是上一道题的变体呢~核心思路是首先对数组进行排序，然后使用四个指针（或称为迭代变量）来遍历数组，找出所有不重复的四元组，使得这四个数的和等于给定的目标和。<br><strong>由此，用同样的思路也可以求五数之和，六数之和</strong></p><p>具体思路如下：</p><ol><li><p><strong>初始化结果列表</strong>：<br>创建一个空的ArrayList <code>res</code>，用于存储满足条件的四元组。</p></li><li><p><strong>对数组进行排序</strong>：<br>使用<code>Arrays.sort(nums)</code>对输入的整数数组<code>nums</code>进行排序。排序有助于减少不必要的遍历，并允许我们利用数组的有序性来避免重复结果。</p></li><li><p><strong>外层循环遍历数组</strong>：<br>使用指针<code>i</code>从数组的第一个元素开始遍历。在遍历过程中，需要注意以下情况：</p><ul><li>如果<code>nums[i]</code>大于0且<code>nums[i]</code>已经大于目标和<code>target</code>，由于数组已排序，后续所有元素也都会大于<code>target</code>，因此直接返回结果列表。</li><li>如果<code>i</code>不是数组的第一个元素，并且<code>nums[i]</code>与前一个元素<code>nums[i-1]</code>相同，则跳过此次循环，避免结果重复。</li></ul></li><li><p><strong>第二层循环遍历数组</strong>：<br>使用指针<code>k</code>从<code>i</code>的下一个位置开始遍历。在遍历过程中，同样要注意跳过重复的元素。</p></li><li><p><strong>使用双指针寻找另外两个数</strong>：<br>对于每一对<code>nums[i]</code>和<code>nums[k]</code>，使用双指针<code>left</code>和<code>right</code>分别指向<code>k</code>的下一个位置和数组末尾。双指针的作用是在已排序的数组中找到两个数，使得与<code>nums[i]</code>和<code>nums[k]</code>的和等于目标和<code>target</code>。</p><ul><li>当<code>left &lt; right</code>时，计算当前四个数的和<code>sum</code>。<ul><li>如果<code>sum</code>等于目标和<code>target</code>，则找到了一个符合要求的四元组，将其添加到结果列表中，并移动<code>left</code>和<code>right</code>指针，跳过重复的元素。</li><li>如果<code>sum</code>大于目标和<code>target</code>，说明当前的和偏大，需要减小和，因此将<code>right</code>指针左移。</li><li>如果<code>sum</code>小于目标和<code>target</code>，说明当前的和偏小，需要增大和，因此将<code>left</code>指针右移。</li></ul></li></ul></li><li><p><strong>返回结果</strong>：<br>当遍历完所有可能的<code>nums[i]</code>和<code>nums[k]</code>组合后，返回结果列表<code>res</code>。</p></li></ol><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>这个算法的时间复杂度是O(n^3)，其中n是数组的长度。因为排序的复杂度是O(n log n)，而遍历数组和三层循环的复杂度是O(n^3)。尽管复杂度相对较高，但在实际应用中，对于中等大小的输入，这个算法通常是足够高效的。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++){</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;nums[i]&gt;target)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i+<span class="number">1</span>;k&lt;nums.length;k++){</span><br><span class="line">            <span class="keyword">if</span>(k&gt;i+<span class="number">1</span>&amp;&amp;nums[k]==nums[k-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left=k+<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">                <span class="type">int</span> sum=nums[i]+nums[k]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum==target){</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[k],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>])right--;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target){</span><br><span class="line">                    right--;</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target){</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题-哈希表day5</title>
      <link href="/2024/03/25/suan-fa-shua-ti-ha-xi-biao-day5/"/>
      <url>/2024/03/25/suan-fa-shua-ti-ha-xi-biao-day5/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li>字符串长度<code>s.length()</code>,数组长度<code>s.length</code></li><li><strong>数组==null和数组长度为0不是同一个意思</strong>。<br><code>数组 == null</code> 是检查数组变量是否指向一个数组对象，而 <code>数组长度为0</code> 是检查数组对象是否包含任何元素。两者都是检查数组的不同方面，因此它们的意义并不相同。</li><li><code>Java set</code>基本操作</li></ol><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>add()</td><td>添加元素</td></tr><tr><td>contains()</td><td>判断元素是否存在于集合当中</td></tr><tr><td>remove()</td><td>删除集合中的元素</td></tr><tr><td>clear()</td><td>删除集合中所有元素</td></tr><tr><td>size()</td><td>计算集合中的元素数量</td></tr><tr><td>for-each</td><td>迭代 HashSet 中的元素</td></tr></tbody></table><ol start="4"><li><code>Java map</code>基本操作</li></ol><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>boolean containsKey(Object k)</td><td>如果此映射包含指定键的映射关系，则返回 true。</td></tr><tr><td>boolean containsValue(Object v)(Object v)</td><td>如果此映射将一个或多个键映射到指定值，则返回 true。</td></tr><tr><td>Set entrySet( )</td><td>返回此映射中包含的映射关系的 Set 视图。</td></tr><tr><td>boolean equals(Object obj)</td><td>比较指定的对象与此映射是否相等。</td></tr><tr><td>Object get(Object k)</td><td>返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td></tr><tr><td>int hashCode( )</td><td>返回此映射的哈希码值。</td></tr><tr><td>boolean isEmpty( )</td><td>如果此映射未包含键-值映射关系，则返回 true。</td></tr><tr><td>Set keySet( )</td><td>返回此映射中包含的键的 Set 视图。</td></tr><tr><td>Object put(Object k, Object v)</td><td>将指定的值与此映射中的指定键关联</td></tr><tr><td>Object remove(Object k)</td><td>如果存在一个键的映射关系，则将其从此映射中移除</td></tr><tr><td>int size( )</td><td>返回此映射中的键-值映射关系数。</td></tr></tbody></table><h2 id="Problem-242-有效的字母异位词"><a href="#Problem-242-有效的字母异位词" class="headerlink" title="Problem: 242. 有效的字母异位词"></a>Problem: <a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>变位词是指两个单词，它们包含相同数量和种类的字母，但顺序不同。题目中说只有小写字母</p><ol><li><p><strong>初始化字符计数数组</strong>：</p><ul><li>创建一个长度为26的整数数组<code>chars</code>。这个数组用于记录每个<strong>小写字母</strong>在字符串<code>s</code>中出现的次数。数组的每个索引对应一个小写字母（’a’到’z’），而值则是该字母在<code>s</code>中出现的次数。</li></ul></li><li><p><strong>统计字符串<code>s</code>中每个字符的出现次数</strong>：</p><ul><li>遍历字符串<code>s</code>的每个字符。</li><li>对于每个字符，通过<code>s.charAt(i) - 'a'</code>计算其在<code>chars</code>数组中的索引（因为字符’a’的ASCII码值减去’a’的ASCII码值等于0，字符’b’的ASCII码值减去’a’的ASCII码值等于1，以此类推）。</li><li>将对应索引的值加1，表示该字符在<code>s</code>中出现了一次。</li></ul></li><li><p><strong>从字符计数数组中减去字符串<code>t</code>中每个字符的出现次数</strong>：</p><ul><li>遍历字符串<code>t</code>的每个字符。</li><li>同样地，计算每个字符在<code>chars</code>数组中的索引。</li><li>将对应索引的值减1，表示从<code>s</code>中的计数中减去该字符在<code>t</code>中的出现次数。</li></ul></li><li><p><strong>检查字符计数数组是否全为零</strong>：</p><ul><li>如果<code>s</code>和<code>t</code>是变位词，那么对于所有字符，<code>s</code>中的出现次数应该等于<code>t</code>中的出现次数。因此，在减去<code>t</code>中的字符出现次数后，<code>chars</code>数组中的所有值都应该为零。</li><li>遍历<code>chars</code>数组，检查每个值是否为零。</li><li>如果发现任何非零值，则返回<code>false</code>，表示<code>s</code>和<code>t</code>不是变位词。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>如果<code>chars</code>数组中所有值都是零，说明<code>s</code>和<code>t</code>是变位词，返回<code>true</code>。</li></ul></li></ol><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n)，n是字符串<code>s</code>和<code>t</code>的长度之和，因为每个字符只被遍历一次。</p><p>空间复杂度:<br>O(1)</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> {</span><br><span class="line">        <span class="type">int</span> []chars=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            chars[s.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++){</span><br><span class="line">            chars[t.charAt(i)-<span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> count:chars){</span><br><span class="line">            <span class="keyword">if</span>(count!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-349-两个数组的交集"><a href="#Problem-349-两个数组的交集" class="headerlink" title="Problem: 349. 两个数组的交集"></a>Problem: <a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349. 两个数组的交集</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>计算两个整数数组<code>nums1</code>和<code>nums2</code>的交集。使用Set，具体思路如下：</p><ol><li><p><strong>边界情况处理</strong>：</p><ul><li>如果<code>nums1</code>或<code>nums2</code>中的任何一个为<code>null</code>，或者它们的长度为0，那么它们的交集自然是空集。因此，方法直接返回一个新的空整数数组。</li></ul></li><li><p><strong>创建HashSet集合</strong>：</p><ul><li>创建一个<code>HashSet</code>集合<code>set1</code>，用于存储数组<code>nums1</code>中的元素。</li><li>创建一个<code>HashSet</code>集合<code>set2</code>，用于存储两个数组的交集元素。</li></ul></li><li><p><strong>填充set1</strong>：</p><ul><li>遍历数组<code>nums1</code>，将每个元素添加到<code>set1</code>中。由于<code>HashSet</code>的特性，重复的元素会被自动过滤掉，因此<code>set1</code>中只会包含<code>nums1</code>中的唯一元素。</li></ul></li><li><p><strong>计算交集并填充set2</strong>：</p><ul><li>遍历数组<code>nums2</code>，对于每个元素：<ul><li>如果该元素存在于<code>set1</code>中（即它也是<code>nums1</code>的元素），则将其添加到<code>set2</code>中。</li></ul></li><li>这一步结束后，<code>set2</code>中包含了两个数组的交集元素。</li></ul></li><li><p><strong>转换并返回结果</strong>：</p><ul><li>使用Java 8的Stream API，将<code>set2</code>中的元素转换为一个整数流。</li><li>使用<code>mapToInt</code>方法将流中的元素转换为<code>int</code>类型。</li><li>最后，使用<code>toArray</code>方法将流转换为整数数组。</li></ul></li></ol><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:O(n+m)</p><p>空间复杂度:O(n)</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) {</span><br><span class="line">      <span class="keyword">if</span>(nums1==<span class="literal">null</span>||nums2==<span class="literal">null</span>||nums1.length==<span class="number">0</span>||nums2.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">0</span>];</span><br><span class="line">      Set&lt;Integer&gt; set1=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      Set&lt;Integer&gt; set2=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x:nums1){</span><br><span class="line">        set1.add(x);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x:nums2){</span><br><span class="line">        <span class="keyword">if</span>(set1.contains(x)){</span><br><span class="line">            set2.add(x);</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> set2.stream().mapToInt(x-&gt;x).toArray();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-202-快乐数"><a href="#Problem-202-快乐数" class="headerlink" title="Problem: 202. 快乐数"></a>Problem: <a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>判断一个正整数<code>n</code>是否是一个“快乐数”。快乐数的定义是：一个正整数，按照如下方式反复替换，最终能够得到数字1。对于正整数<code>n</code>，用<code>n</code>的每个位上的数字的平方和得到一个新的数，重复这个过程，直到结果为1。</p><ol><li><p><strong>初始化HashSet集合</strong>：<br>使用<code>HashSet</code>集合<code>set1</code>来记录已经出现的数</p></li><li><p><strong>主循环</strong>：<br>使用<code>while</code>循环，条件是<code>n</code>不等于1且<code>n</code>没有出现在<code>set1</code>中。循环体执行以下操作：</p><ul><li>将<code>n</code>添加到<code>set1</code>中，以记录已经访问过这个数。</li><li>调用<code>getNextNumber</code>方法，获取<code>n</code>的下一个数（即每个位上数字的平方和），并将结果赋值给<code>n</code>。</li></ul></li><li><p><strong>判断结果</strong>：<br>循环结束后，检查<code>n</code>是否等于1。如果等于1，说明<code>n</code>是一个快乐数，返回<code>true</code>；否则，不是一个快乐数，返回<code>false</code>。</p></li></ol><p><code>getNextNumber</code>方法用于计算一个数的下一个数，即每个位上数字的平方和。具体步骤如下：</p><ul><li>初始化一个变量<code>res</code>为0，用于存储平方和的结果。</li><li>使用<code>while</code>循环，条件是<code>x</code>不等于0。循环体执行以下操作：<ul><li>计算<code>x</code>的个位数<code>tmp</code>（即<code>x</code>除以10的余数）。</li><li>将<code>tmp</code>的平方加到<code>res</code>上。</li><li>更新<code>x</code>为<code>x</code>除以10的商，即去掉个位数。</li></ul></li><li>循环结束后，返回<code>res</code>作为结果。</li></ul><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        Set&lt;Integer&gt; set1 =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span>&amp;&amp;!set1.contains(n)){</span><br><span class="line">            set1.add(n);</span><br><span class="line">            n=getNextNumber(n);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextNumber</span><span class="params">(<span class="type">int</span> x)</span>{</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>){</span><br><span class="line">            <span class="type">int</span> tmp=x%<span class="number">10</span>;</span><br><span class="line">            res+=tmp*tmp;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-1-两数之和"><a href="#Problem-1-两数之和" class="headerlink" title="Problem: 1. 两数之和"></a>Problem: <a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>使用一个<code>HashMap</code>来存储数组元素和它们对应的下标。遍历数组时，对于每个元素<code>nums[i]</code>，我们检查<code>target - nums[i]</code>是否已经在<code>HashMap</code>中。如果在，说明我们找到了两个数的和为目标值，直接返回这两个数的下标。如果不在，就将当前元素<code>nums[i]</code>和它的下标<code>i</code>存入<code>HashMap</code>中，以便后续的查找。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>先find再insert，保证不会和自己匹配。在遍历数组时，先在<code>HashMap</code>中查找<code>target - nums[i]</code>，然后再将当前元素<code>nums[i]</code>和其下标<code>i</code>存入<code>HashMap</code>。这样做的原因是，如果我们先存入再查找，那么对于数组中的每个元素，我们可能会错误地将其与自身匹配，即它的两倍等于<code>target</code>。但是题目要求的是两个<strong>不同</strong>的数的和，所以我们需要避免这种自匹配的情况。</p><p>举个例子，假设<code>nums = [3, 3]</code>，<code>target = 6</code>。如果我们先存入再查找，那么对于第一个元素3，我们会将其存入<code>HashMap</code>，然后查找<code>target - nums[0] = 3</code>，发现<code>HashMap</code>中已经存在这个键，于是返回<code>[0, 0]</code>，这是错误的。正确的答案应该是没有解，因为数组中不存在两个不同的数的和为6。</p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:O(n)</p><p>空间复杂度:O(n)</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) {</span><br><span class="line">       Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++){</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target-nums[i])){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{map.get(target-nums[i]),i};</span><br><span class="line">        }</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//笔记：先find再insert，保证不会和自己匹配。</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题-链表day4</title>
      <link href="/2024/03/23/suan-fa-shua-ti-lian-biao-day4/"/>
      <url>/2024/03/23/suan-fa-shua-ti-lian-biao-day4/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem-24-两两交换链表中的节点"><a href="#Problem-24-两两交换链表中的节点" class="headerlink" title="Problem: 24. 两两交换链表中的节点"></a>Problem: <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点</a></h2><h3 id="虚拟头结点的使用"><a href="#虚拟头结点的使用" class="headerlink" title="虚拟头结点的使用"></a>虚拟头结点的使用</h3><p>在链表头部进行插入、删除或其他操作时，或者当需要简化链表处理的边界条件检查时，使用虚拟头节点</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p><strong>创建虚拟头节点（dummy）</strong>:</p><ul><li>为了简化头节点的处理，我们创建一个虚拟头节点（dummy），并将其next指针指向原链表的头节点（head）。这样做的好处是，即使在交换头节点和第二个节点时，我们也能保证链表的连续性，因为虚拟头节点总是指向当前的“头节点”。</li></ul></li><li><p><strong>初始化指针</strong>:</p><ul><li><code>cur</code> 指针用于遍历链表。它初始时指向虚拟头节点。</li><li><code>first</code> 和 <code>second</code> 指针用于指向每一对要交换的相邻节点。</li><li><code>tmp</code> 指针用于暂存<code>second</code>节点的下一个节点，以便在交换后能够继续遍历链表。</li></ul></li><li><p><strong>遍历链表并交换节点</strong>:</p><ul><li>使用<code>while</code>循环遍历链表。循环的条件是<code>cur.next</code>和<code>cur.next.next</code>都不为null，确保我们总是有一对相邻的节点可以交换。</li><li>在循环内部，我们首先更新<code>first</code>和<code>second</code>指针，分别指向当前要交换的一对节点。</li><li>然后，我们使用<code>tmp</code>暂存<code>second</code>节点的下一个节点。</li><li>接下来，我们进行节点的交换：<ul><li>将<code>cur</code>的next指针指向<code>second</code>节点。</li><li>将<code>second</code>节点的next指针指向<code>first</code>节点。</li><li>将<code>first</code>节点的next指针指向<code>tmp</code>节点，即原<code>second</code>节点的下一个节点。</li></ul></li><li>最后，我们更新<code>cur</code>指针，使其指向<code>first</code>节点，以便在下一次循环中处理下一对节点。</li></ul></li><li><p><strong>返回结果</strong>:</p><ul><li>由于我们使用了虚拟头节点，所以最终返回的是<code>dummy.next</code>，即处理后的链表的头节点。</li></ul></li></ol><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n)</p><p>空间复杂度:<br>O(1)</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() {}</span><br><span class="line"> *     ListNode(int val) { this.val = val; }</span><br><span class="line"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">    public ListNode swapPairs(ListNode head) {</span><br><span class="line">        ListNode dummy=new ListNode(-1);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode cur=dummy;</span><br><span class="line">        ListNode first;</span><br><span class="line">        ListNode second;</span><br><span class="line">        ListNode tmp;</span><br><span class="line">        while(cur.next!=null&amp;&amp;cur.next.next!=null)</span><br><span class="line">        {</span><br><span class="line">            first=cur.next;</span><br><span class="line">            second=cur.next.next;</span><br><span class="line">            tmp=cur.next.next.next;</span><br><span class="line">            cur.next=second;</span><br><span class="line">            second.next=first;</span><br><span class="line">            first.next=tmp;</span><br><span class="line">            cur=first;</span><br><span class="line">        }</span><br><span class="line">        return dummy.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-19-删除链表的倒数第-N-个结点"><a href="#Problem-19-删除链表的倒数第-N-个结点" class="headerlink" title="Problem: 19. 删除链表的倒数第 N 个结点"></a>Problem: <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19. 删除链表的倒数第 N 个结点</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用快慢指针来删除链表中倒数第n个节点。具体思路如下：</p><ol><li><p><strong>创建虚拟头节点</strong>：</p><ul><li>为了处理删除头节点的情况，我们引入一个虚拟头节点（dummy），并将其next指针指向原链表的头节点（head）。这样，无论要删除的节点是头节点还是其他节点，我们都可以通过操作虚拟头节点的next指针来完成删除操作。</li></ul></li><li><p><strong>初始化快慢指针</strong>：</p><ul><li>初始化两个指针，fast（快指针）和slow（慢指针），都指向虚拟头节点（dummy）。</li></ul></li><li><p><strong>快指针先走n+1步</strong>：</p><ul><li>快指针fast先向前移动n+1步。这样做的目的是让快指针和慢指针之间保持一个n的距离。当快指针和慢指针同时移动时，慢指针会指向要删除的节点的前一个节点。</li></ul></li><li><p><strong>快慢指针同时移动</strong>：</p><ul><li>当快指针fast不为null时，快指针和慢指针同时向前移动。因为快指针比慢指针先走了n+1步，所以在这个过程中，快指针和慢指针之间始终保持n个节点的距离。</li></ul></li><li><p><strong>删除节点</strong>：</p><ul><li>当快指针fast到达链表末尾（即fast.next为null）时，慢指针slow刚好指向要删除的节点的前一个节点。此时，我们只需要将slow的next指针指向要删除节点的下一个节点，即完成了删除操作。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>由于我们使用了虚拟头节点，所以最终返回的是<code>dummy.next</code>，即处理后的链表的头节点。</li></ul></li></ol><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n)</p><p>空间复杂度:<br>O(1)</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> {</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">       dummy.next=head;</span><br><span class="line">       ListNode fast=dummy;</span><br><span class="line">       ListNode slow=dummy;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)fast=fast.next;<span class="comment">//让快指针走n+1步，这样一会快慢指针一起移动时慢指针会走到删除结点的前一个</span></span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="literal">null</span>)</span><br><span class="line">       {</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">       }</span><br><span class="line">       slow.next=slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-面试题-02-07-链表相交"><a href="#Problem-面试题-02-07-链表相交" class="headerlink" title="Problem: 面试题 02.07. 链表相交"></a>Problem: <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题 02.07. 链表相交</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>如果两个链表相交，那么从相交点开始，它们的后续节点都是相同的；如果两个链表不相交，则返回null。</p><p>以下是该代码的思路：</p><ol><li><p><strong>计算两个链表的长度</strong>：</p><ul><li>使用两个指针<code>curA</code>和<code>curB</code>分别遍历两个链表<code>headA</code>和<code>headB</code>，同时计算它们的长度<code>lenA</code>和<code>lenB</code>。</li></ul></li><li><p><strong>调整指针位置</strong>：</p><ul><li>比较两个链表的长度，将较长的链表的头指针<code>curA</code>和长度<code>lenA</code>与较短的链表的对应变量进行交换。</li><li>这样做的目的是为了让两个指针<code>curA</code>和<code>curB</code>从相同的位置开始遍历，即较长的链表先向前移动<code>lenB - lenA</code>步，使得两个指针距离链表尾部的距离相同。</li></ul></li><li><p><strong>寻找相交节点</strong>：</p><ul><li>从调整后的位置开始，同时遍历两个链表，每次移动<code>curA</code>和<code>curB</code>指针。</li><li>如果两个链表相交，那么它们会在某个节点上相遇，此时返回该节点。</li><li>如果两个链表不相交，那么<code>curA</code>或<code>curB</code>会先到达链表尾部（null），此时返回null。</li></ul></li></ol><blockquote><p>关于使用虚拟头节点的问题，在这个问题中，使用虚拟头节点并没有直接的好处。因为算法的核心在于比较两个链表的长度，并据此调整指针的起始位置，然后同时遍历两个链表以找到相交点。虚拟头节点主要用于处理<strong>删除头节点或头节点插入</strong>的特殊情况，但在这个问题中，我们并不需要在链表头部进行任何操作。</p></blockquote><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n + m)</p><p>空间复杂度:<br>O(1)</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> {</span><br><span class="line">       ListNode curA=headA;</span><br><span class="line">       ListNode curB=headB;</span><br><span class="line">       <span class="type">int</span> lenA=<span class="number">0</span>,lenB=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(curA!=<span class="literal">null</span>)</span><br><span class="line">       {</span><br><span class="line">            lenA++;</span><br><span class="line">            curA=curA.next;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">while</span>(curB!=<span class="literal">null</span>){</span><br><span class="line">        lenB++;</span><br><span class="line">        curB=curB.next;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">        curA=headA;</span><br><span class="line">        curB=headB;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(lenA&gt;lenB)</span><br><span class="line">       {</span><br><span class="line">        <span class="type">int</span> tmp=lenA;</span><br><span class="line">        lenA=lenB;</span><br><span class="line">        lenB=tmp;</span><br><span class="line">        ListNode tmpN=curA;</span><br><span class="line">        curA=curB;</span><br><span class="line">        curB=tmpN;</span><br><span class="line">       }</span><br><span class="line">       <span class="type">int</span> l=lenB-lenA;</span><br><span class="line">       <span class="keyword">while</span>(l-- &gt;<span class="number">0</span>)</span><br><span class="line">       {</span><br><span class="line">        curB=curB.next;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">while</span>(curB!=<span class="literal">null</span>)</span><br><span class="line">       {</span><br><span class="line">         <span class="keyword">if</span>(curA==curB)<span class="keyword">return</span> curA;</span><br><span class="line">        curB=curB.next;</span><br><span class="line">        curA=curA.next;</span><br><span class="line">       </span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-142-环形链表-II"><a href="#Problem-142-环形链表-II" class="headerlink" title="Problem: 142. 环形链表 II"></a>Problem: <a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II</a></h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>检测一个单链表中是否有环，并返回环的入口节点。如果链表没有环，则返回null。</p><p>以下是该代码的思路：</p><ol><li><p><strong>使用快慢指针检测环</strong>：</p><ul><li>初始化两个指针，<code>fast</code>（快指针）和<code>slow</code>（慢指针），都指向链表的头节点<code>head</code>。</li><li>快指针每次移动两步，慢指针每次移动一步。</li><li>如果链表中存在环，那么快慢指针最终会在环内的某个节点相遇。</li><li>如果链表中没有环，那么快指针会先到达链表的尾部（null），此时可以判断链表没有环。</li></ul></li><li><p><strong>找到环的入口节点</strong>：</p><ul><li>当快慢指针相遇时，设相遇点为<code>meet</code>。</li><li>此时，慢指针<code>slow</code>已经走了<code>s</code>步（假设链表头到环入口的距离为<code>x</code>，环入口到相遇点的距离为<code>y</code>，则<code>s = x + y</code>）。</li><li>快指针<code>fast</code>由于速度是慢指针的两倍，所以走了<code>2s</code>步。由于快指针比慢指针多走了一个环的周长<code>c</code>，所以<code>2s = s + c</code>，即<code>s = c</code>。</li><li>这意味着，从链表头到环入口的距离<code>x</code>，与从相遇点到环入口的距离相等。</li><li>因此，我们可以将两个指针分别重新指向链表头和相遇点，然后每次各自前进一步，直到它们再次相遇。相遇点即为环的入口节点。</li></ul></li></ol><p>代码中的具体实现：</p><ul><li><code>while(fast!=null&amp;&amp;fast.next!=null)</code>：确保快指针<code>fast</code>不会越界，即不会访问到null的next属性。</li><li><code>if(fast==slow)</code>：当快慢指针相遇时，执行寻找环入口节点的逻辑。</li><li><code>ListNode index1=slow; ListNode index2=head;</code>：初始化两个新指针<code>index1</code>和<code>index2</code>，分别指向相遇点和链表头。</li><li><code>while(index1!=index2)</code>：通过每次移动<code>index1</code>和<code>index2</code>各一步，直到它们相遇，找到环的入口节点。</li></ul><p>最后，如果快慢指针没有相遇，即链表没有环，则返回null。</p><h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n)，其中n是链表的长度。因为快指针最多遍历两遍链表（一次是找到相遇点，另一次是与慢指针一起找到环入口点），慢指针最多遍历一遍链表。</p><p>空间复杂度:<br>O(1)，因为只使用了常数个指针变量</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> {</span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=head;</span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>){</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow){</span><br><span class="line">            ListNode index1=slow;</span><br><span class="line">            ListNode index2=head;</span><br><span class="line">            <span class="keyword">while</span>(index1!=index2)</span><br><span class="line">            {</span><br><span class="line">                index1=index1.next;</span><br><span class="line">                index2=index2.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> index1;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题-链表day3</title>
      <link href="/2024/03/22/suan-fa-shua-ti-lian-biao-day3/"/>
      <url>/2024/03/22/suan-fa-shua-ti-lian-biao-day3/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem-203-移除链表元素"><a href="#Problem-203-移除链表元素" class="headerlink" title="Problem: 203. 移除链表元素"></a>Problem: <a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p><strong>边界情况处理</strong>：首先，如果传入的链表头节点<code>head</code>是<code>null</code>，说明链表为空，直接返回<code>null</code>。</p></li><li><p><strong>创建哑节点（Dummy Node）</strong>：在链表的头部创建一个新的节点<code>dummy</code>，其值为-1（这个值其实不重要，重要的是它是一个非<code>val</code>值），并且它的<code>next</code>指针指向原链表的头节点<code>head</code>。哑节点的引入可以简化删除头节点的情况，因为即使头节点需要被删除，我们也不需要特殊处理。我们只需要更新<code>dummy.next</code>即可。</p></li><li><p><strong>初始化指针</strong>：设置两个指针<code>pre</code>（前驱节点）和<code>now</code>（当前节点）。<code>pre</code>初始化为哑节点<code>dummy</code>，<code>now</code>初始化为原链表的头节点<code>head</code>。</p></li><li><p><strong>遍历链表</strong>：使用<code>while</code>循环遍历链表，直到<code>now</code>节点为<code>null</code>，即到达链表尾部。</p><ul><li><strong>检查当前节点值</strong>：如果<code>now</code>节点的值等于<code>val</code>，说明需要删除该节点。此时，我们更新<code>pre.next</code>为<code>now.next</code>，即跳过<code>now</code>节点，实现删除。</li><li><strong>否则</strong>：如果<code>now</code>节点的值不等于<code>val</code>，则不需要删除，我们只需要将<code>pre</code>移动到<code>now</code>，以便在下一次循环中检查<code>now</code>的下一个节点。</li></ul></li><li><p><strong>返回新链表头节点</strong>：当循环结束后，所有值为<code>val</code>的节点都已被删除。此时，返回<code>dummy.next</code>作为新链表的头节点。</p></li></ol><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n)<br>空间复杂度:<br>O(1)</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        ListNode pre=dummy;</span><br><span class="line">        ListNode now=head;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">if</span>(now.val==val){</span><br><span class="line">                pre.next=now.next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                pre=now;</span><br><span class="line">            }</span><br><span class="line">            now=now.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-707-设计链表"><a href="#Problem-707-设计链表" class="headerlink" title="Problem: 707. 设计链表"></a>Problem: <a href="https://leetcode.cn/problems/design-linked-list/description/">707. 设计链表</a></h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p><strong>边界检查</strong>：</p><ul><li>在<code>get</code>方法中，需要确保传入的<code>index</code>在有效范围内（即<code>0</code>到<code>size - 1</code>之间）。如果<code>index</code>小于<code>0</code>或大于等于<code>size</code>，应该返回错误值<code>-1</code>。</li><li>在<code>addAtIndex</code>方法中，如果<code>index</code>大于链表当前的<code>size</code>，应直接返回，不执行添加操作。如果<code>index</code>小于<code>0</code>，将其修正为<code>0</code>，表示在链表头部添加元素。</li><li>在<code>deleteAtIndex</code>方法中，也需要进行类似的边界检查，确保<code>index</code>在有效范围内。</li></ul></li><li><p>**<code>addAtIndex</code>**：</p><ul><li>在<code>addAtIndex</code>方法中，添加新节点时，首先创建一个新节点<code>toAdd</code>，然后设置<code>toAdd.next</code>为<code>pre.next</code>，最后设置<code>pre.next</code>为<code>toAdd</code>。这个顺序很重要，因为如果先设置<code>pre.next</code>为<code>toAdd</code>，那么就会丢失对原<code>pre.next</code>节点的引用，导致链表断裂。</li><li>在<code>addAtIndex</code>方法中，添加节点后需要增加链表的长度<code>size</code>。</li></ul></li><li><p>**<code>deleteAtIndex</code>**：</p><ul><li>在<code>deleteAtIndex</code>方法中，删除节点时，只需要将<code>pre.next</code>设置为<code>pre.next.next</code>即可，这样就跳过了要删除的节点。</li><li>注意，如果<code>index</code>是链表的最后一个元素的索引，那么<code>pre.next</code>将会是<code>null</code>，此时不需要做任何操作,仍然保持为<code>null</code>。</li><li>在<code>deleteAtIndex</code>方法中，删除节点后需要减少链表的长度<code>size</code>。</li></ul></li><li><p><strong>虚拟头节点</strong>：</p><ul><li>使用虚拟头节点<code>head</code>简化对链表头部的操作，因为无需单独处理链表为空的情况。</li></ul></li></ol><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>涉及 index 的相关操作为 O(index), 其余为 O(1)</p><p>空间复杂度:<br>O(n)</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>{</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(){</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    ListNode(<span class="type">int</span> val){</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head;<span class="comment">//虚拟头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> {</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=size)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        ListNode cur=head.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++){</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> {</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)<span class="keyword">return</span>;</span><br><span class="line">        size++;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++){</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        }</span><br><span class="line">        ListNode toAdd=<span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next=pre.next;</span><br><span class="line">        pre.next=toAdd;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=size)<span class="keyword">return</span>;</span><br><span class="line">        size--;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++){</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        }</span><br><span class="line">        pre.next=pre.next.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-206-反转链表"><a href="#Problem-206-反转链表" class="headerlink" title="Problem: 206. 反转链表"></a>Problem: <a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p><strong>初始化指针</strong>：</p><ul><li><code>pre</code> 初始化为 <code>null</code>，因为在反转链表的过程中，第一个节点的 <code>next</code> 应该指向 <code>null</code>。</li><li><code>cur</code> 初始化为链表的头节点 <code>head</code>，这是我们开始反转的起点。</li><li><code>tmp</code> 用于暂存 <code>cur</code> 的下一个节点，以便在更改 <code>cur.next</code> 之前可以保留对下一个节点的引用。</li></ul></li><li><p><strong>遍历链表并反转节点</strong>：</p><ul><li>使用一个 <code>while</code> 循环，直到 <code>cur</code> 为 <code>null</code>，即遍历完整个链表。</li><li>在循环内部，首先保存 <code>cur</code> 的下一个节点到 <code>tmp</code>，因为接下来会改变 <code>cur.next</code> 的指向。</li><li>然后，将 <code>cur.next</code> 指向 <code>pre</code>，即反转当前节点的指向。</li><li>接着，更新 <code>pre</code> 和 <code>cur</code> 的位置，<code>pre</code> 移动到当前节点 <code>cur</code>，<code>cur</code> 移动到下一个节点 <code>tmp</code>。</li></ul></li><li><p><strong>返回新的头节点</strong>：</p><ul><li>当 <code>cur</code> 为 <code>null</code> 时，说明链表已经遍历完毕，所有节点都已经反转。</li><li>此时，<code>pre</code> 指向的是原链表的最后一个节点，它现在是反转后链表的头节点。</li><li>因此，返回 <code>pre</code> 作为反转后的链表的头节点。</li></ul></li></ol><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br> O(n)</p><p>空间复杂度:<br>O(1)</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) { this.val = val; }</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> {</span><br><span class="line">        ListNode pre=<span class="literal">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        ListNode tmp=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>){</span><br><span class="line">            tmp=cur.next;</span><br><span class="line">        cur.next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=tmp;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2024/03/21/redis/"/>
      <url>/2024/03/21/redis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一次更新：2024/3/21</p></blockquote><h2 id="何为Redis？"><a href="#何为Redis？" class="headerlink" title="何为Redis？"></a>何为<code>Redis</code>？</h2><p>可以理解为在内存中存储数据，适用于分布式系统；而对于单机架构，直接用变量存储则是更优的选择；</p><p><code>Redis</code>基于网络，可以把自己内存中的变量给别的主机进程使用；</p><p>与<code>MySQL</code>相比，<code>Redis</code>快，但存储空间有限；</p><p>一般使用<code>Redis</code>+<code>MySQL</code>，可以满足“二八原则”；但是这样系统的复杂度也会增加，同时，也涉及<code>Redis</code>和<code>MySQL</code>的同步问题</p><hr><h2 id="何为分布式系统？"><a href="#何为分布式系统？" class="headerlink" title="何为分布式系统？"></a>何为分布式系统？</h2><p>首先先说一下<strong>单机架构</strong>：只有一台服务器，负责所有工作（应用服务+数据库服务）。<br>而一台主机的硬件资源有限，服务器处理请求需要消耗资源，此时，想要处理大量请求，<strong>要么</strong>加硬件，<strong>要么</strong>性能测试，对症下药。<br>一台主机最终会被拓展到极限–&gt;此时，引入多台主机，即<strong>分布式系统</strong>。</p><p><strong>分布式系统中提高性能、可靠性、稳定性有哪些具体方案呢?</strong></p><ul><li><strong>应用服务器和数据库服务器分离</strong>：对于前者重点配置<code>CPU</code>和内存资源，对于后者重点配置硬盘资源。</li><li><strong>引入更多应用服务器节点，通过负载均衡器分配请求</strong>。</li><li><strong>数据库读写分离</strong>：主数据库负责写，从数据库负责读，一般是“一主多从”。</li><li><strong>缓存</strong>：将数据分为冷、热数据。缓存中放热数据，只占全量数据的一小部分（二八原则）。</li><li>数据量过大，一台服务器存不下时：使用多台主机对数据库进行拆分，“<strong>分库分表</strong>”</li><li><strong>微服务</strong>：一个复杂的服务器拆分为更多功能单一更小的服务器。<ul><li><strong>优点</strong>：1. 功能复用 2. 不同功能不同部署</li><li><strong>缺点</strong>：1. 性能下降，因为微服务间通过网络通信。缓解办法：加硬件资源 2. 系统复杂性增加。缓解办法：监控报警+维护人员。</li></ul></li></ul><hr><h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a><code>Redis</code>特性</h2><blockquote><p>整理自官网，并加入自己的理解</p></blockquote><ol><li><strong>在内存中存储数据</strong>：以<code>&lt;key,value&gt;</code>方式存储组织数据</li><li><strong>可编程性</strong>：简单交互式命令/脚本</li><li><strong>可拓展性</strong>：可用<code>C、C++、Rust</code>编写<code>Redis</code>扩展，使其支持更多地数据结构</li><li><strong>持久化</strong>：内存数据掉电会丢失，<code>Redis</code>会把数据备份到硬盘</li><li><strong>集群化</strong>： 即水平扩展，支持多个<code>Redis</code>节点，每个Redis存储一部分数据。是不是很像分库分表？</li><li><strong>高可用</strong>：冗余 “主从”</li><li><strong>快</strong> ，原因如下：</li></ol><ul><li>数据在内存中</li><li>核心功能为操作简单数据结构</li><li>使用<code>I/O</code>多路复用</li><li>使用单线程模型，减少不必要的线程之间的竞争开销<br><strong>那么问题来了，为什么用单线程模型还能快呢？</strong><br><strong>原因</strong>：多线程提高效率的前提时<code>CPU</code>密集型任务，而<code>Redis</code>不会吃很多<code>CPU</code>，因为第<code>2</code>条原因</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题-数组基础day2</title>
      <link href="/2024/03/21/suan-fa-shua-ti-shu-zu-ji-chu-day2/"/>
      <url>/2024/03/21/suan-fa-shua-ti-shu-zu-ji-chu-day2/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem-977-有序数组的平方"><a href="#Problem-977-有序数组的平方" class="headerlink" title="Problem: 977. 有序数组的平方"></a>Problem: <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p><strong>暴力做法</strong>：<br>如果我们直接对每个数字进行平方计算，然后将结果放入一个新数组并排序，虽然这样做可以解决问题，但效率不高。因为排序操作的时间复杂度通常是 O(n log n)。</p></li><li><p><strong>双指针策略</strong>：<br>我们可以考虑是否有更优的方法。观察到，负数平方后变正且绝对值较小的负数平方后得到的值较小，而正数平方后值增大。<br>基于这一点，我们可以使用双指针，一个指向数组的起始位置（处理可能的负数），另一个指向数组的末尾（处理正数）。比较这两个指针所指向的数字的平方，将较大的平方值放入结果数组的末尾。由于我们是<strong>从后往前</strong>填充结果数组，因此较大的平方值应该先被放置。</p></li></ol><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n)</p><p>空间复杂度:<br>O(1)</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) {</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> k=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r){</span><br><span class="line">            <span class="keyword">if</span>(nums[l]*nums[l]&gt;nums[r]*nums[r]){</span><br><span class="line">                res[k]=nums[l]*nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res[k]=nums[r]*nums[r]; </span><br><span class="line">                r--;</span><br><span class="line">            }</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-209-长度最小的子数组"><a href="#Problem-209-长度最小的子数组" class="headerlink" title="Problem: 209. 长度最小的子数组"></a>Problem: <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p><strong>问题分析</strong>：<br>首先，我们需要理解问题的本质：找到数组中和至少为<code>target</code>的最短连续子数组。这意味着我们需要对数组进行某种形式的遍历，并在遍历过程中跟踪子数组的和以及子数组的长度。</p><p>观察到，如果我们有一个子数组的和已经超过了<code>target</code>，那么我们可以尝试去掉子数组的左端元素，看是否能得到一个更短的满足条件的子数组。这启发我们使用双指针来维护一个滑动窗口，窗口内的元素和即为当前子数组的和。</p></li><li><p><strong>双指针与滑动窗口</strong>：<br>在这个问题中，我们使用左指针<code>l</code>和右指针<code>r</code>来定义一个滑动窗口。右指针用于扩展窗口（增加子数组的元素），左指针用于缩小窗口（减少子数组的元素）。</p><p>通过移动这两个指针，我们可以灵活地调整子数组的大小，并计算子数组的和。</p></li><li><p><strong>和的计算与比较</strong>：<br>在遍历过程中，我们累加右指针指向的元素到<code>sum</code>中，直到<code>sum</code>大于等于<code>target</code>。一旦<code>sum</code>满足条件，我们就尝试通过移动左指针来缩小子数组的长度，并更新最短子数组的长度记录<code>res</code>。</p><p>这种策略允许我们在单次遍历中找到所有可能的满足条件的子数组，并通过比较它们的长度来找到最短的那一个。</p></li><li><p><strong>边界处理与结果返回</strong>：<br>最后，我们需要考虑边界情况。如果遍历完整个数组都没有找到满足条件的子数组，那么<code>res</code>将保持为初始值<code>Integer.MAX_VALUE</code>。在这种情况下，我们返回0，表示不存在这样的子数组。</p><p>否则，我们返回<code>res</code>，即找到的最短子数组的长度。</p></li></ol><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n)</p><p>空间复杂度:<br>O(1)</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> {</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,sum=<span class="number">0</span>,res=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;nums.length;r++){</span><br><span class="line">                sum+=nums[r];</span><br><span class="line">                <span class="keyword">while</span>(sum&gt;=target){</span><br><span class="line">                    res=Math.min(res,r-l+<span class="number">1</span>);</span><br><span class="line">                    sum-=nums[l];</span><br><span class="line">                    l++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res==Integer.MAX_VALUE?<span class="number">0</span>:res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Problem-59-螺旋矩阵-II"><a href="#Problem-59-螺旋矩阵-II" class="headerlink" title="Problem: 59. 螺旋矩阵 II"></a>Problem: <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这个算法的思路是基于模拟螺旋矩阵填充的过程。将其分为以下几个步骤：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>确定矩阵的大小<code>n</code>，并创建一个<code>n x n</code>的二维数组<code>res</code>用于存储结果。</li><li>设置几个变量来辅助算法的进行，包括<code>loop</code>（当前处理的螺旋环数）、<code>start</code>（当前螺旋环的起始位置）、<code>count</code>（当前要填充的数字）。</li></ul></li><li><p><strong>确定螺旋环的层数</strong>：</p><ul><li>对于一个<code>n x n</code>的矩阵，螺旋环的层数不会超过<code>n/2</code>。这是因为每一层螺旋环都包含矩阵的边界，而每一层处理完后，边界会向内缩进。</li></ul></li><li><p><strong>按层处理螺旋环</strong>：</p><ul><li>使用<code>while</code>循环，根据<code>loop</code>的值确定当前处理的螺旋环。</li><li>在每一层中，我们按照“右、下、左、上”的顺序遍历矩阵的边界，并填充数字。<ul><li>首先，从左到右填充顶部的行。</li><li>然后，从上到下填充右侧的列。</li><li>接着，从右到左填充底部的行。</li><li>最后，从下到上填充左侧的列。</li></ul></li><li>在处理完一层后，<code>start</code>（起始位置）会向矩阵中心移动一格，为处理下一层做准备。</li></ul></li><li><p><strong>处理中心元素</strong>：</p><ul><li>如果<code>n</code>是奇数，那么矩阵的中心会剩下一个单独的元素。在循环结束后，需要特别处理这个中心元素，将其填充为下一个数字。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>当所有螺旋环处理完毕后，返回填充好的矩阵<code>res</code>。</li></ul></li></ol><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><p>这个问题就是模拟，虽然没有固定的模板可以直接套用，但我们可以总结该题通用的关键点便于记忆：</p><ol><li><p><strong>边界控制</strong>：<br>通过维护四个边界（上、下、左、右），我们可以控制螺旋的填充过程。在填充过程中，根据需要更新边界的位置，从而控制螺旋向内收缩。</p></li><li><p><strong>方向控制</strong>：<br>可以定义一个变量来指示当前填充的方向（例如，0表示向右，1表示向下，2表示向左，3表示向上）。在每次填充完一行或一列后，更新方向变量，以改变填充的方向。</p></li><li><p><strong>层次处理</strong>：<br>将螺旋矩阵视为多个层次的环，从外层到内层逐层处理。每一层的处理逻辑相似，但边界和起始位置会有所不同。</p></li><li><p><strong>特殊情况处理</strong>：<br>对于奇数大小的矩阵，中心会有一个单独的元素。在算法中需要特别处理这种情况，确保中心元素被正确填充。</p></li></ol><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度:<br>O(n^2)</p><p>空间复杂度:<br>O(1)</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) {</span><br><span class="line">        <span class="type">int</span> loop=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> [][]res=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop++&lt;n/<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">for</span>(j=start;j&lt;n-loop;j++){</span><br><span class="line">                res[start][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(i=start;i&lt;n-loop;i++){</span><br><span class="line">                res[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;=loop;j--){</span><br><span class="line">                res[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;=loop;i--){</span><br><span class="line">                res[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            start++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>){</span><br><span class="line">                res[start][start]=count;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题-数组基础day1</title>
      <link href="/2024/03/20/suan-fa-shua-ti-shu-zu-ji-chu-day1/"/>
      <url>/2024/03/20/suan-fa-shua-ti-shu-zu-ji-chu-day1/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem-704-二分查找"><a href="#Problem-704-二分查找" class="headerlink" title="Problem: 704. 二分查找"></a>Problem: <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>二分查找，重点是边界的判断</p></blockquote><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><ol><li>第一种写法：左闭右闭区间 <code>[left, right]</code></li></ol><ul><li><p>区间定义：目标值 <code>target</code> 在区间 <code>[left, right]</code> 内。</p></li><li><p>关键点：</p><ul><li><p>循环条件：使用 <code>while (left &lt;= right)</code>，因为当 <code>left == right</code> 时，中间元素 <code>nums[middle]</code> 可能就是目标值，所以需要检查。</p></li><li><p>边界更新：</p><ul><li>如果 <code>nums[middle] &gt; target</code>，则更新 <code>right = middle - 1</code>，因为当前 <code>nums[middle]</code>不是目标值，且由于区间是左闭右闭的，所以 <code>middle</code> 不应包含在下一轮搜索的右区间中。</li><li>如果 <code>nums[middle] &lt; target</code>，则更新 <code>left = middle + 1</code>，因为当前 <code>nums[middle]</code> 不是目标值，且下一轮搜索的左区间应从 middle 的下一个位置开始。</li></ul></li></ul></li></ul><ol start="2"><li>第二种写法：左闭右开区间 <code>[left, right)</code></li></ol><ul><li><p>区间定义：目标值 <code>target</code> 在区间 <code>[left, right)</code> 内。</p></li><li><p>关键点：</p><ul><li><p>循环条件：使用 <code>while (left &lt; right)</code>，因为当 <code>left == right</code> 时，区间 <code>[left, right)</code> 内没有元素，所以不需要检查。</p></li><li><p>边界更新：</p><ul><li>如果 <code>nums[middle] &gt; target</code>，则更新 <code>right = middle</code>，因为当前 <code>nums[middle]</code> 不是目标值，且由于区间是左闭右开的，所以<code>middle</code> 不应包含在下一轮搜索的右区间中。</li><li>如果 <code>nums[middle] &lt; target</code>，则更新 <code>left = middle + 1</code>，与第一种写法相同，因为 <code>middle</code> 也不应包含在下一轮搜索的左区间中。</li></ul></li></ul></li></ul><p><strong>注意事项</strong><br>在二分查找中，<code>middle</code> 的计算通常使用 <code>int middle = left+(right - left) / 2</code>;<br>而不是 <code>int middle = (left + right) / 2</code>;<br>这是为了避免当 <code>left</code> 和 <code>right</code>都很大时，它们的和可能会导致整数溢出。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:</p><blockquote><p>O(log n)</p></blockquote><p>空间复杂度:</p><blockquote><p>O(1)</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右闭区间 [left, right]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r){</span><br><span class="line">            <span class="type">int</span> mid=(r+l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> num=nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(num==target){</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;target){</span><br><span class="line">                r=mid-<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右开区间 [left, right)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">      <span class="type">int</span> l=<span class="number">0</span>,r=nums.length;</span><br><span class="line">      <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">        <span class="type">int</span> mid=(r+l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]){</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]){</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">           r=mid;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Problem-27-移除元素"><a href="#Problem-27-移除元素" class="headerlink" title="Problem: 27. 移除元素"></a>Problem: <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote><p>双指针法</p></blockquote><h2 id="解题方法-1"><a href="#解题方法-1" class="headerlink" title="解题方法"></a>解题方法</h2><ul><li>具体来说，我们使用两个指针<code>l</code>和<code>r</code>，它们都从数组的开始位置（索引为<code>0</code>）开始。其中，<code>l</code>指针用于指向下一个非<code>val</code>元素应该存放的位置，而<code>r</code>指针用于遍历整个数组。</li><li>在遍历过程中，如果<code>nums[r]</code>不等于<code>val</code>，说明当前元素是需要保留的，那么我们就把它放到<code>l</code>指针所指向的位置，并且<code>l</code>指针向前移动一位，以指向下一个非<code>val</code>元素应该存放的位置。如果<code>nums[r]</code>等于<code>val</code>，那么我们就跳过这个元素，<code>l</code>指针不动，只让<code>r</code>指针继续向前遍历。</li><li>遍历完成后，<code>l</code>指针所指向的位置就是数组中最后一个非<code>val</code>元素的下一个位置，也就是移除<code>val</code>元素后数组的新长度。因此，我们返回<code>l</code>作为结果。</li></ul><p><strong>总结</strong>： 在这个算法中，<code>l</code>和<code>r</code>指针初始时都指向数组的第一个元素。随着遍历的进行，<code>r</code>指针可能会走得比<code>l</code>指针快，因为当遇到值为<code>val</code>的元素时，<code>r</code>指针会继续向前移动，而<code>l</code>指针则保持不变。当遍历结束时，<code>l</code>指针指向的就是新数组（移除<code>val</code>后）的末尾位置。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:</p><blockquote><p>O(n)</p></blockquote><p>空间复杂度:</p><blockquote><p>O(1)</p></blockquote><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> {</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;nums.length;r++){</span><br><span class="line">                <span class="keyword">if</span>(nums[r]!=val){</span><br><span class="line">                    nums[l]=nums[r];</span><br><span class="line">                    l++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之系统调用</title>
      <link href="/2024/03/19/cao-zuo-xi-tong-zhi-xi-tong-diao-yong/"/>
      <url>/2024/03/19/cao-zuo-xi-tong-zhi-xi-tong-diao-yong/</url>
      
        <content type="html"><![CDATA[<p>我们可以通过命令行来使用到操作系统提供的功能，那么输入一个命令行后发生了什么？下面举一个实际的<strong>例子</strong>来说明：</p><p><strong>有关操作</strong>：<br>你编写了一个<code>output.c</code>文件，该程序内容如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ECHO:%s\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后，你在命令行输入<code>gcc -o output output.c</code></p><blockquote><p>这条命令的意思是：使用 GCC 编译器编译 output.c文件，并将编译后的可执行文件命名为 output</p></blockquote><p><strong>这时</strong>，在命令行输入 <code>./output "hello"</code><br>得到结果： <code>ECHO:hello</code></p><p>那么输入一个命令行后发生了什么才得到我们想要的<strong>结果</strong>了呢？</p><p><strong>首先</strong>，说明<strong>命令的含义</strong>：就是一段程序。<br>程序要编译，程序编译完后生成可执行文件，刚才我们已经说明。</p><p><code>./ouput</code>运行可执行文件，那么<code>“hello”</code>究竟是怎么读到的呢？<br>这就是<code>shell</code>所做的工作，<code>shell</code>的本质也是一段程序，关键代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char * argv[])</span><br><span class="line">{</span><br><span class="line">    char cmd[20];</span><br><span class="line">    while(1){</span><br><span class="line">        scanf("%s",cmd);</span><br><span class="line">        if(!fork()){exec(cmd);}</span><br><span class="line">        else wait();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>关键代码说明</strong><br><code>if (!fork())</code>：调用 <code>fork()</code> 函数创建一个子进程。<code>fork()</code> 返回一个正整数（父进程的PID）给父进程，返回0给子进程。因此，<code>!fork()</code> 的条件只在子进程中为真。</p><p><code>exec(cmd)</code>：在子进程中，调用 <code>exec</code> 函数来执行用户输入的命令。</p><p><code>else wait()</code>：在父进程中，调用 <code>wait()</code> 函数等待子进程结束。<code>wait()</code> 会阻塞父进程，直到任意一个子进程结束。</p><p>那么什么是<strong>操作系统接口</strong>呢？</p><p>就是函数，比如刚才的<code>printf</code>，而<code>printf</code>包装了一个系统调用<code>write()</code>。</p><p>所以说接口表现为函数调用，又由系统提供，所以称为系统调用,即<code>System_call</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 系统调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之SpringCloud</title>
      <link href="/2024/03/18/wei-fu-wu-zhi-springcloud/"/>
      <url>/2024/03/18/wei-fu-wu-zhi-springcloud/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><code>Spring Cloud Alibaba</code> 是阿里开源的一套微服务开发组件，致力于提供微服务开发的一站式解决方案，核心组件有下面这些：</p><ul><li><code>Sentinel</code>：以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>Nacos</code>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Seata</code>：分布式事务解决方案。</li><li><code>OpenFeign</code>：轻量级 RESTful 的 HTTP 服务客户端，用于替代已经进入停更维护状态的 Feign（Netflix Feign）</li><li><code>Gateway</code>：用于网关服务，实现请求的转发和路由。</li><li><code>Ribbon</code>：用于客户端负载均衡，将请求分发给不同的微服务实例。</li></ul><h3 id="2-实践选择："><a href="#2-实践选择：" class="headerlink" title="2.实践选择："></a>2.实践选择：</h3><p>本次实践选用的组件如下：</p><ul><li><code>Eureka</code> 实现服务注册与发现(<code>Netflix</code>)</li><li><code>Gateway</code> 实现 <code>API</code> 网关</li><li><code>Ribbon</code> 实现负载均衡（<code>Feign</code> 内置）</li><li><code>Feign</code> 实现基于 <code>Feign</code> 的服务调用</li><li><code>Hystrix</code> 实现服务熔断（<code>Feign</code> 内置）</li><li><code>Config</code> 实现 <code>Config</code> 配置中心</li></ul><p>&lt;picture项目逻辑架构&gt;</p><h3 id="3-SpringCloud-聚合项目的创建"><a href="#3-SpringCloud-聚合项目的创建" class="headerlink" title="3.SpringCloud 聚合项目的创建"></a>3.SpringCloud 聚合项目的创建</h3><h4 id="3-1聚合项目及其作用"><a href="#3-1聚合项目及其作用" class="headerlink" title="3.1聚合项目及其作用"></a>3.1聚合项目及其作用</h4><ol><li>创建聚合项目的目的:</li></ol><ul><li>更好地管理和组织多个相关联的项目，可以统一管理它们的<strong>依赖关系</strong>，统一<strong>打包发布</strong>，方便项目的构建和部署。</li><li>聚合项目也可以提高团队协作效率，统一管理项目的<strong>版本和发布流程</strong>。</li><li>聚合项目还可以方便地进行跨项目的<strong>代码重用和共享</strong>，提高代码的<strong>复用性和可维护性</strong>。</li></ul><h4 id="3-2-聚合项目（父级项目、顶级项目）的Maven配置说明"><a href="#3-2-聚合项目（父级项目、顶级项目）的Maven配置说明" class="headerlink" title="3.2 聚合项目（父级项目、顶级项目）的Maven配置说明"></a>3.2 聚合项目（父级项目、顶级项目）的Maven配置说明</h4><p><strong>聚合项目特性</strong></p><p>聚合项目本身也是一个Maven项目，其核心在于管理和协调多个子模块。这样的设计有助于消除子模块POM中的重复配置，提升项目的可维护性。</p><p><strong>关键配置要点</strong></p><ol><li><strong>POM文件</strong>：聚合项目必须有自己的<code>pom.xml</code>文件。</li><li><strong>打包方式</strong>：聚合项目的打包方式必须是<code>pom</code>，因为它不包含任何实际代码。</li><li><strong>目录结构</strong>：聚合模块仅包含<code>pom.xml</code>文件，不包含<code>src/main/java</code>和<code>src/test/java</code>等目录。</li></ol><p><strong>引入新元素</strong></p><ul><li><strong>modules-module</strong>：用于声明聚合的子模块，每个子模块都是一个独立的项目。</li></ul><p><strong>版本一致性</strong></p><ul><li>聚合模块的版本应与被聚合的子模块版本保持一致，以确保依赖关系的一致性。</li></ul><p><strong>路径配置</strong></p><ul><li><strong>relative path</strong>：每个子模块的名称都应是当前POM文件的相对目录。</li></ul><p><strong>目录命名约定</strong></p><ul><li>为了方便定位，建议模块所在的目录与其<code>artifactId</code>保持一致。但这不是硬性要求，重要的是模块目录必须与聚合模块中声明的模块目录相匹配。</li></ul><p><strong>目录结构选择</strong></p><ul><li>聚合模块与子模块可以是父子级结构，也可以是平行结构。推荐使用平行结构，因为它有助于保持项目结构的清晰和易于维护。如果使用平行结构，需要在POM文件中相应调整目录路径配置。</li></ul><p><strong>删除子模块注意事项</strong></p><ul><li>如果从聚合项目中删除了某个子模块，务必在聚合模块的<code>pom.xml</code>文件中的<code>modules</code>选项中删除对应的子模块声明，以避免潜在的配置错误。</li></ul><h4 id="3-3实操演练"><a href="#3-3实操演练" class="headerlink" title="3.3实操演练"></a>3.3实操演练</h4><blockquote><p> 待更新…….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/03/17/suan-fa/"/>
      <url>/2024/03/17/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS-宽度优先搜索"><a href="#BFS-宽度优先搜索" class="headerlink" title="BFS 宽度优先搜索"></a>BFS 宽度优先搜索</h1><h4 id="1-基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾"><a href="#1-基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾" class="headerlink" title="1. 基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾"></a>1. 基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾</h4><blockquote><p>理解拓展：目前做的2道题-迷宫有关，拓展的是队头的上下左右（2维迷宫）/向北、向南、向东、向西、向上、向下（3维迷宫）</p></blockquote><blockquote><p>BFS最先输出的肯定是最短路径，因为是按宽度搜索的；求最短路径的题可以想想宽搜</p></blockquote><h4 id="2-模板如下："><a href="#2-模板如下：" class="headerlink" title="2. 模板如下："></a>2. 模板如下：</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 判重数组st[]  //入队时判重</span><br><span class="line">2. queue</span><br><span class="line">    queue&lt;-初始状态</span><br><span class="line">    while(queue非空)</span><br><span class="line">    {</span><br><span class="line">        t&lt;-队头 //队头出队</span><br><span class="line">        for(拓展t)</span><br><span class="line">        {</span><br><span class="line">            v&lt;-新节点</span><br><span class="line">            if(!st[v])</span><br><span class="line">            {</span><br><span class="line">                v-&gt;队尾</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="3-具体习题"><a href="#3-具体习题" class="headerlink" title="3. 具体习题"></a>3. 具体习题</h4><h5 id="3-1-献给阿尔吉侬的花束-二维"><a href="#3-1-献给阿尔吉侬的花束-二维" class="headerlink" title="3.1 献给阿尔吉侬的花束(二维)"></a>3.1 <a href="https://www.acwing.com/problem/content/1103/">献给阿尔吉侬的花束(二维)</a></h5><p>具体代码实现如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"></span><br><span class="line">const int N = 210;</span><br><span class="line"></span><br><span class="line">char a[N][N];</span><br><span class="line">int dis[N][N];</span><br><span class="line"></span><br><span class="line">void bfs(PII start)</span><br><span class="line">{</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.push(start);//队头队，对应步骤1</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        PII u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int dx[4] = {-1, 0, 1, 0};</span><br><span class="line">        int dy[4] = {0, 1, 0 ,-1};</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)//遍历四个方向，对应步骤2</span><br><span class="line">        {</span><br><span class="line">            int x = u.first + dx[i];</span><br><span class="line">            int y = u.second + dy[i];</span><br><span class="line"></span><br><span class="line">            if(a[x][y] == '#') continue;//如果是'#',不做任何处理</span><br><span class="line">            if(a[x][y] == '.')//如果是 '.'，更新对应内容</span><br><span class="line">            {</span><br><span class="line">                dis[x][y] = dis[u.first][u.second] + 1;</span><br><span class="line">                a[x][y] = '#';</span><br><span class="line">                q.push({x, y});</span><br><span class="line">            }</span><br><span class="line">            if(a[x][y] == 'E')//如果是'E'，找到了，输出</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; dis[u.first][u.second] + 1 &lt;&lt; endl;</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; "oop!" &lt;&lt; endl;//没有找到</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t--)</span><br><span class="line">    {</span><br><span class="line">        memset(a, '#', sizeof(a));//初始化地图，各个点都是墙。</span><br><span class="line">        memset(dis, 0, sizeof(dis));//初始化dis</span><br><span class="line">        int n,m;</span><br><span class="line">        PII start;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)//从第一行存储地图，因为四周都是墙，bfs时，可以不做越界判断</span><br><span class="line">        {</span><br><span class="line">            for(int j = 1; j &lt;= m; j++)//从第一；列存储地图，因为四周都是墙，bfs时，可以不做越界判断</span><br><span class="line">            {</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                if(a[i][j] == 'S')//记录下起点位置。</span><br><span class="line">                    start.first = i, start.second = j, a[i][j] = '#';</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        bfs(start);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="3-2-地牢大师-三维"><a href="#3-2-地牢大师-三维" class="headerlink" title="3.2 地牢大师(三维)"></a>3.2 <a href="https://www.acwing.com/problem/content/1098/">地牢大师(三维)</a></h5><p>仿照刚才二维的题，给出具体代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">{</span><br><span class="line">    int x,y,z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">char m[N][N][N];//地图</span><br><span class="line">int dis[N][N][N];</span><br><span class="line">int l,r,c;</span><br><span class="line">int dx[6] = {-1, 0, 1, 0, 0, 0}, dy[6] = {0, 1, 0, -1, 0, 0}, dz[6] = {0, 0, 0, 0, 1, -1};</span><br><span class="line"></span><br><span class="line">int bfs(Point start)</span><br><span class="line">{</span><br><span class="line">    queue&lt;Point&gt; q;</span><br><span class="line">    </span><br><span class="line">    q.push(start);</span><br><span class="line">    </span><br><span class="line">    while(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        Point t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;6;i++)</span><br><span class="line">        {</span><br><span class="line">            int x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];</span><br><span class="line">            if(m[x][y][z]=='#')continue;</span><br><span class="line">            if(m[x][y][z]=='.')</span><br><span class="line">            {</span><br><span class="line">                dis[x][y][z]=dis[t.x][t.y][t.z]+1;</span><br><span class="line">                m[x][y][z]='#';</span><br><span class="line">                q.push({x,y,z});</span><br><span class="line">            }</span><br><span class="line">            if(m[x][y][z]=='E')</span><br><span class="line">            {</span><br><span class="line">                return dis[t.x][t.y][t.z]+1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    while(scanf("%d%d%d",&amp;l,&amp;r,&amp;c),l||r||c)</span><br><span class="line">    {</span><br><span class="line">        memset(m,'#',sizeof(m));</span><br><span class="line">        memset(dis,0,sizeof(dis));</span><br><span class="line">        Point start,end;</span><br><span class="line">        for(int i=1;i&lt;=l;i++)</span><br><span class="line">        {</span><br><span class="line">            for(int j=1;j&lt;=r;j++)</span><br><span class="line">            {</span><br><span class="line">                for(int k=1;k&lt;=c;k++)</span><br><span class="line">                {</span><br><span class="line">                    cin&gt;&gt;m[i][j][k];</span><br><span class="line">                    if(m[i][j][k]=='S')start={i,j,k};</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        int distance=bfs(start);</span><br><span class="line">        if(distance==-1)puts("Trapped!");</span><br><span class="line">        else printf("Escaped in %d minute(s).\n",distance);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>其实可以看出很强的规律性，这两道题的做法几乎可以一模一样；等我再做几道题找找规律</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复盘</title>
      <link href="/2024/03/15/fu-pan/"/>
      <url>/2024/03/15/fu-pan/</url>
      
        <content type="html"><![CDATA[<h3 id="2024-3-15"><a href="#2024-3-15" class="headerlink" title="2024/3/15"></a>2024/3/15</h3><blockquote><p>开学将近两周了，今天起，每日记录自己的收获，学习笔记心得啥的，多动脑多记录多实践，现在是2024/3/15 23:51，开始记录，也是对自己的检讨和复盘，即使调整学习状态吧</p></blockquote><p><strong>今日收获</strong></p><ol><li><code>leetcode</code>刷了7道题</li><li>八股计网看完了，操作系统看了一半</li></ol><p><code>今天没学太多，上午起来后就去上课了，晚上开始就一直焦虑摆烂刷帖子，有效学习就在下午，满打满算也就学了3个小时。</code><br><code>又开始焦虑了，总是认为只能兼顾一头，实际上时间是很够的，多学习多思考，我的学习能力不差的，焦虑的时候不看帖子群聊啥的了，专注提升自己的技术吧，多多实践</code></p><p><code>加油</code></p><h3 id="2024-3-17"><a href="#2024-3-17" class="headerlink" title="2024/3/17"></a>2024/3/17</h3><p><strong>今日收获</strong></p><ol><li>双指针算法，`BFS算法，图论算法各一题，找时间写博客总结</li><li>数学学习，多背背结论，这是为了站在高起点</li><li><code>SpringCloud</code>学习，搭建基础项目结构</li></ol><blockquote><p>调整为周计划待办的方式记录学习</p></blockquote><h3 id="2024-3-18"><a href="#2024-3-18" class="headerlink" title="2024/3/18"></a>2024/3/18</h3><p><strong>本周待办</strong></p><ol><li>70道leetcode</li><li>八股 保质</li><li>OS实验</li><li>高数一元微分学</li><li>每日单词</li><li>微服务项目，不确定难度，这周摸索一下，不要求做的太多</li><li>…</li></ol>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心灵对话 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
