<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务之SpringCloud</title>
      <link href="/2024/03/18/wei-fu-wu-zhi-springcloud/"/>
      <url>/2024/03/18/wei-fu-wu-zhi-springcloud/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><code>Spring Cloud Alibaba</code> 是阿里开源的一套微服务开发组件，致力于提供微服务开发的一站式解决方案，核心组件有下面这些：</p><ul><li><code>Sentinel</code>：以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>Nacos</code>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Seata</code>：分布式事务解决方案。</li><li><code>OpenFeign</code>：轻量级 RESTful 的 HTTP 服务客户端，用于替代已经进入停更维护状态的 Feign（Netflix Feign）</li><li><code>Gateway</code>：用于网关服务，实现请求的转发和路由。</li><li><code>Ribbon</code>：用于客户端负载均衡，将请求分发给不同的微服务实例。</li></ul><h3 id="2-实践选择："><a href="#2-实践选择：" class="headerlink" title="2.实践选择："></a>2.实践选择：</h3><p>本次实践选用的组件如下：</p><ul><li><code>Eureka</code> 实现服务注册与发现(<code>Netflix</code>)</li><li><code>Gateway</code> 实现 <code>API</code> 网关</li><li><code>Ribbon</code> 实现负载均衡（<code>Feign</code> 内置）</li><li><code>Feign</code> 实现基于 <code>Feign</code> 的服务调用</li><li><code>Hystrix</code> 实现服务熔断（<code>Feign</code> 内置）</li><li><code>Config</code> 实现 <code>Config</code> 配置中心</li></ul><p>&lt;picture项目逻辑架构&gt;</p><h3 id="3-SpringCloud-聚合项目的创建"><a href="#3-SpringCloud-聚合项目的创建" class="headerlink" title="3.SpringCloud 聚合项目的创建"></a>3.SpringCloud 聚合项目的创建</h3><h4 id="3-1聚合项目及其作用"><a href="#3-1聚合项目及其作用" class="headerlink" title="3.1聚合项目及其作用"></a>3.1聚合项目及其作用</h4><ol><li>创建聚合项目的目的:</li></ol><ul><li>更好地管理和组织多个相关联的项目，可以统一管理它们的<strong>依赖关系</strong>，统一<strong>打包发布</strong>，方便项目的构建和部署。</li><li>聚合项目也可以提高团队协作效率，统一管理项目的<strong>版本和发布流程</strong>。</li><li>聚合项目还可以方便地进行跨项目的<strong>代码重用和共享</strong>，提高代码的<strong>复用性和可维护性</strong>。</li></ul><h4 id="3-2-聚合项目（父级项目、顶级项目）的Maven配置说明"><a href="#3-2-聚合项目（父级项目、顶级项目）的Maven配置说明" class="headerlink" title="3.2 聚合项目（父级项目、顶级项目）的Maven配置说明"></a>3.2 聚合项目（父级项目、顶级项目）的Maven配置说明</h4><p><strong>聚合项目特性</strong></p><p>聚合项目本身也是一个Maven项目，其核心在于管理和协调多个子模块。这样的设计有助于消除子模块POM中的重复配置，提升项目的可维护性。</p><p><strong>关键配置要点</strong></p><ol><li><strong>POM文件</strong>：聚合项目必须有自己的<code>pom.xml</code>文件。</li><li><strong>打包方式</strong>：聚合项目的打包方式必须是<code>pom</code>，因为它不包含任何实际代码。</li><li><strong>目录结构</strong>：聚合模块仅包含<code>pom.xml</code>文件，不包含<code>src/main/java</code>和<code>src/test/java</code>等目录。</li></ol><p><strong>引入新元素</strong></p><ul><li><strong>modules-module</strong>：用于声明聚合的子模块，每个子模块都是一个独立的项目。</li></ul><p><strong>版本一致性</strong></p><ul><li>聚合模块的版本应与被聚合的子模块版本保持一致，以确保依赖关系的一致性。</li></ul><p><strong>路径配置</strong></p><ul><li><strong>relative path</strong>：每个子模块的名称都应是当前POM文件的相对目录。</li></ul><p><strong>目录命名约定</strong></p><ul><li>为了方便定位，建议模块所在的目录与其<code>artifactId</code>保持一致。但这不是硬性要求，重要的是模块目录必须与聚合模块中声明的模块目录相匹配。</li></ul><p><strong>目录结构选择</strong></p><ul><li>聚合模块与子模块可以是父子级结构，也可以是平行结构。推荐使用平行结构，因为它有助于保持项目结构的清晰和易于维护。如果使用平行结构，需要在POM文件中相应调整目录路径配置。</li></ul><p><strong>删除子模块注意事项</strong></p><ul><li>如果从聚合项目中删除了某个子模块，务必在聚合模块的<code>pom.xml</code>文件中的<code>modules</code>选项中删除对应的子模块声明，以避免潜在的配置错误。</li></ul><h4 id="3-3实操演练"><a href="#3-3实操演练" class="headerlink" title="3.3实操演练"></a>3.3实操演练</h4><blockquote><p> 待更新…….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/03/17/suan-fa/"/>
      <url>/2024/03/17/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS-宽度优先搜索"><a href="#BFS-宽度优先搜索" class="headerlink" title="BFS 宽度优先搜索"></a>BFS 宽度优先搜索</h1><h4 id="1-基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾"><a href="#1-基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾" class="headerlink" title="1. 基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾"></a>1. 基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾</h4><blockquote><p>理解拓展：目前做的2道题-迷宫有关，拓展的是队头的上下左右（2维迷宫）/向北、向南、向东、向西、向上、向下（3维迷宫）</p></blockquote><blockquote><p>BFS最先输出的肯定是最短路径，因为是按宽度搜索的；求最短路径的题可以想想宽搜</p></blockquote><h4 id="2-模板如下："><a href="#2-模板如下：" class="headerlink" title="2. 模板如下："></a>2. 模板如下：</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 判重数组st[]  //入队时判重</span><br><span class="line">2. queue</span><br><span class="line">    queue&lt;-初始状态</span><br><span class="line">    while(queue非空)</span><br><span class="line">    {</span><br><span class="line">        t&lt;-队头 //队头出队</span><br><span class="line">        for(拓展t)</span><br><span class="line">        {</span><br><span class="line">            v&lt;-新节点</span><br><span class="line">            if(!st[v])</span><br><span class="line">            {</span><br><span class="line">                v-&gt;队尾</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="3-具体习题"><a href="#3-具体习题" class="headerlink" title="3. 具体习题"></a>3. 具体习题</h4><h5 id="3-1-献给阿尔吉侬的花束-二维"><a href="#3-1-献给阿尔吉侬的花束-二维" class="headerlink" title="3.1 献给阿尔吉侬的花束(二维)"></a>3.1 <a href="https://www.acwing.com/problem/content/1103/">献给阿尔吉侬的花束(二维)</a></h5><p>具体代码实现如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"></span><br><span class="line">const int N = 210;</span><br><span class="line"></span><br><span class="line">char a[N][N];</span><br><span class="line">int dis[N][N];</span><br><span class="line"></span><br><span class="line">void bfs(PII start)</span><br><span class="line">{</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.push(start);//队头队，对应步骤1</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        PII u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int dx[4] = {-1, 0, 1, 0};</span><br><span class="line">        int dy[4] = {0, 1, 0 ,-1};</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)//遍历四个方向，对应步骤2</span><br><span class="line">        {</span><br><span class="line">            int x = u.first + dx[i];</span><br><span class="line">            int y = u.second + dy[i];</span><br><span class="line"></span><br><span class="line">            if(a[x][y] == '#') continue;//如果是'#',不做任何处理</span><br><span class="line">            if(a[x][y] == '.')//如果是 '.'，更新对应内容</span><br><span class="line">            {</span><br><span class="line">                dis[x][y] = dis[u.first][u.second] + 1;</span><br><span class="line">                a[x][y] = '#';</span><br><span class="line">                q.push({x, y});</span><br><span class="line">            }</span><br><span class="line">            if(a[x][y] == 'E')//如果是'E'，找到了，输出</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; dis[u.first][u.second] + 1 &lt;&lt; endl;</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; "oop!" &lt;&lt; endl;//没有找到</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t--)</span><br><span class="line">    {</span><br><span class="line">        memset(a, '#', sizeof(a));//初始化地图，各个点都是墙。</span><br><span class="line">        memset(dis, 0, sizeof(dis));//初始化dis</span><br><span class="line">        int n,m;</span><br><span class="line">        PII start;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)//从第一行存储地图，因为四周都是墙，bfs时，可以不做越界判断</span><br><span class="line">        {</span><br><span class="line">            for(int j = 1; j &lt;= m; j++)//从第一；列存储地图，因为四周都是墙，bfs时，可以不做越界判断</span><br><span class="line">            {</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                if(a[i][j] == 'S')//记录下起点位置。</span><br><span class="line">                    start.first = i, start.second = j, a[i][j] = '#';</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        bfs(start);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="3-2-地牢大师-三维"><a href="#3-2-地牢大师-三维" class="headerlink" title="3.2 地牢大师(三维)"></a>3.2 <a href="https://www.acwing.com/problem/content/1098/">地牢大师(三维)</a></h5><p>仿照刚才二维的题，给出具体代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">{</span><br><span class="line">    int x,y,z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">char m[N][N][N];//地图</span><br><span class="line">int dis[N][N][N];</span><br><span class="line">int l,r,c;</span><br><span class="line">int dx[6] = {-1, 0, 1, 0, 0, 0}, dy[6] = {0, 1, 0, -1, 0, 0}, dz[6] = {0, 0, 0, 0, 1, -1};</span><br><span class="line"></span><br><span class="line">int bfs(Point start)</span><br><span class="line">{</span><br><span class="line">    queue&lt;Point&gt; q;</span><br><span class="line">    </span><br><span class="line">    q.push(start);</span><br><span class="line">    </span><br><span class="line">    while(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        Point t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;6;i++)</span><br><span class="line">        {</span><br><span class="line">            int x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];</span><br><span class="line">            if(m[x][y][z]=='#')continue;</span><br><span class="line">            if(m[x][y][z]=='.')</span><br><span class="line">            {</span><br><span class="line">                dis[x][y][z]=dis[t.x][t.y][t.z]+1;</span><br><span class="line">                m[x][y][z]='#';</span><br><span class="line">                q.push({x,y,z});</span><br><span class="line">            }</span><br><span class="line">            if(m[x][y][z]=='E')</span><br><span class="line">            {</span><br><span class="line">                return dis[t.x][t.y][t.z]+1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    while(scanf("%d%d%d",&amp;l,&amp;r,&amp;c),l||r||c)</span><br><span class="line">    {</span><br><span class="line">        memset(m,'#',sizeof(m));</span><br><span class="line">        memset(dis,0,sizeof(dis));</span><br><span class="line">        Point start,end;</span><br><span class="line">        for(int i=1;i&lt;=l;i++)</span><br><span class="line">        {</span><br><span class="line">            for(int j=1;j&lt;=r;j++)</span><br><span class="line">            {</span><br><span class="line">                for(int k=1;k&lt;=c;k++)</span><br><span class="line">                {</span><br><span class="line">                    cin&gt;&gt;m[i][j][k];</span><br><span class="line">                    if(m[i][j][k]=='S')start={i,j,k};</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        int distance=bfs(start);</span><br><span class="line">        if(distance==-1)puts("Trapped!");</span><br><span class="line">        else printf("Escaped in %d minute(s).\n",distance);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>其实可以看出很强的规律性，这两道题的做法几乎可以一模一样；等我再做几道题找找规律</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20240315</title>
      <link href="/2024/03/15/20240315/"/>
      <url>/2024/03/15/20240315/</url>
      
        <content type="html"><![CDATA[<blockquote><p>开学将近两周了，今天起，每日记录自己的收获，学习笔记心得啥的，多动脑多记录多实践，现在是2024/3/15 23:51，开始记录，也是对自己的检讨和复盘，即使调整学习状态吧</p></blockquote><p><strong>今日收获</strong></p><ol><li>leetcode刷了7道题</li><li>八股计网看完了，操作系统看了一半</li></ol><p><code>今天没学太多，上午起来后就去上课了，晚上开始就一直焦虑摆烂刷帖子，有效学习就在下午，满打满算也就学了3个小时。</code><br><code>又开始焦虑了，总是认为只能兼顾一头，实际上时间是很够的，多学习多思考，我的学习能力不差的，焦虑的时候不看帖子群聊啥的了，专注提升自己的技术吧，多多实践</code></p><p><code>加油</code></p>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心灵对话 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
