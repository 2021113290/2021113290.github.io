<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/03/21/suan-fa-shua-ti-shu-zu-ji-chu-day2/"/>
      <url>/2024/03/21/suan-fa-shua-ti-shu-zu-ji-chu-day2/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-算法刷题-数组基础day2date-2024-03-21-13-09-09author-XinYutop-truehide-falsecover-truetoc-truemathjax-falsesummary-坚持刷题写博客总结60day计划categories-算法刷题tags-算法-数组基础"><a href="#title-算法刷题-数组基础day2date-2024-03-21-13-09-09author-XinYutop-truehide-falsecover-truetoc-truemathjax-falsesummary-坚持刷题写博客总结60day计划categories-算法刷题tags-算法-数组基础" class="headerlink" title="title: 算法刷题-数组基础day2date: 2024-03-21 13:09:09author: XinYutop: truehide: falsecover: truetoc: truemathjax: falsesummary: 坚持刷题写博客总结60day计划categories: 算法刷题tags:  - 算法  - 数组基础"></a>title: 算法刷题-数组基础day2<br>date: 2024-03-21 13:09:09<br>author: XinYu<br>top: true<br>hide: false<br>cover: true<br>toc: true<br>mathjax: false<br>summary: 坚持刷题写博客总结60day计划<br>categories: 算法刷题<br>tags:<br>  - 算法<br>  - 数组基础</h2><h1 id="Problem-977-有序数组的平方"><a href="#Problem-977-有序数组的平方" class="headerlink" title="Problem: 977. 有序数组的平方"></a>Problem: <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p><strong>暴力做法</strong>：<br>如果我们直接对每个数字进行平方计算，然后将结果放入一个新数组并排序，虽然这样做可以解决问题，但效率不高。因为排序操作的时间复杂度通常是 O(n log n)。</p></li><li><p><strong>双指针策略</strong>：<br>我们可以考虑是否有更优的方法。观察到，负数平方后变正且绝对值较小的负数平方后得到的值较小，而正数平方后值增大。<br>基于这一点，我们可以使用双指针，一个指向数组的起始位置（处理可能的负数），另一个指向数组的末尾（处理正数）。比较这两个指针所指向的数字的平方，将较大的平方值放入结果数组的末尾。由于我们是<strong>从后往前</strong>填充结果数组，因此较大的平方值应该先被放置。</p></li></ol><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:<br>O(n)</p><p>空间复杂度:<br>O(1)</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) {</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> k=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r){</span><br><span class="line">            <span class="keyword">if</span>(nums[l]*nums[l]&gt;nums[r]*nums[r]){</span><br><span class="line">                res[k]=nums[l]*nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res[k]=nums[r]*nums[r]; </span><br><span class="line">                r--;</span><br><span class="line">            }</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Problem-209-长度最小的子数组"><a href="#Problem-209-长度最小的子数组" class="headerlink" title="Problem: 209. 长度最小的子数组"></a>Problem: <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li><p><strong>问题分析</strong>：<br>首先，我们需要理解问题的本质：找到数组中和至少为<code>target</code>的最短连续子数组。这意味着我们需要对数组进行某种形式的遍历，并在遍历过程中跟踪子数组的和以及子数组的长度。</p><p>观察到，如果我们有一个子数组的和已经超过了<code>target</code>，那么我们可以尝试去掉子数组的左端元素，看是否能得到一个更短的满足条件的子数组。这启发我们使用双指针来维护一个滑动窗口，窗口内的元素和即为当前子数组的和。</p></li><li><p><strong>双指针与滑动窗口</strong>：<br>在这个问题中，我们使用左指针<code>l</code>和右指针<code>r</code>来定义一个滑动窗口。右指针用于扩展窗口（增加子数组的元素），左指针用于缩小窗口（减少子数组的元素）。</p><p>通过移动这两个指针，我们可以灵活地调整子数组的大小，并计算子数组的和。</p></li><li><p><strong>和的计算与比较</strong>：<br>在遍历过程中，我们累加右指针指向的元素到<code>sum</code>中，直到<code>sum</code>大于等于<code>target</code>。一旦<code>sum</code>满足条件，我们就尝试通过移动左指针来缩小子数组的长度，并更新最短子数组的长度记录<code>res</code>。</p><p>这种策略允许我们在单次遍历中找到所有可能的满足条件的子数组，并通过比较它们的长度来找到最短的那一个。</p></li><li><p><strong>边界处理与结果返回</strong>：<br>最后，我们需要考虑边界情况。如果遍历完整个数组都没有找到满足条件的子数组，那么<code>res</code>将保持为初始值<code>Integer.MAX_VALUE</code>。在这种情况下，我们返回0，表示不存在这样的子数组。</p><p>否则，我们返回<code>res</code>，即找到的最短子数组的长度。</p></li></ol><h1 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h1><p>时间复杂度:<br>O(n)</p><p>空间复杂度:<br>O(1)</p><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> {</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,sum=<span class="number">0</span>,res=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;nums.length;r++){</span><br><span class="line">                sum+=nums[r];</span><br><span class="line">                <span class="keyword">while</span>(sum&gt;=target){</span><br><span class="line">                    res=Math.min(res,r-l+<span class="number">1</span>);</span><br><span class="line">                    sum-=nums[l];</span><br><span class="line">                    l++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res==Integer.MAX_VALUE?<span class="number">0</span>:res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Problem-59-螺旋矩阵-II"><a href="#Problem-59-螺旋矩阵-II" class="headerlink" title="Problem: 59. 螺旋矩阵 II"></a>Problem: <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II</a></h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这个算法的思路是基于模拟螺旋矩阵填充的过程。将其分为以下几个步骤：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>确定矩阵的大小<code>n</code>，并创建一个<code>n x n</code>的二维数组<code>res</code>用于存储结果。</li><li>设置几个变量来辅助算法的进行，包括<code>loop</code>（当前处理的螺旋环数）、<code>start</code>（当前螺旋环的起始位置）、<code>count</code>（当前要填充的数字）。</li></ul></li><li><p><strong>确定螺旋环的层数</strong>：</p><ul><li>对于一个<code>n x n</code>的矩阵，螺旋环的层数不会超过<code>n/2</code>。这是因为每一层螺旋环都包含矩阵的边界，而每一层处理完后，边界会向内缩进。</li></ul></li><li><p><strong>按层处理螺旋环</strong>：</p><ul><li>使用<code>while</code>循环，根据<code>loop</code>的值确定当前处理的螺旋环。</li><li>在每一层中，我们按照“右、下、左、上”的顺序遍历矩阵的边界，并填充数字。<ul><li>首先，从左到右填充顶部的行。</li><li>然后，从上到下填充右侧的列。</li><li>接着，从右到左填充底部的行。</li><li>最后，从下到上填充左侧的列。</li></ul></li><li>在处理完一层后，<code>start</code>（起始位置）会向矩阵中心移动一格，为处理下一层做准备。</li></ul></li><li><p><strong>处理中心元素</strong>：</p><ul><li>如果<code>n</code>是奇数，那么矩阵的中心会剩下一个单独的元素。在循环结束后，需要特别处理这个中心元素，将其填充为下一个数字。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>当所有螺旋环处理完毕后，返回填充好的矩阵<code>res</code>。</li></ul></li></ol><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>这个问题就是模拟，虽然没有固定的模板可以直接套用，但我们可以总结该题通用的关键点便于记忆：</p><ol><li><p><strong>边界控制</strong>：<br>通过维护四个边界（上、下、左、右），我们可以控制螺旋的填充过程。在填充过程中，根据需要更新边界的位置，从而控制螺旋向内收缩。</p></li><li><p><strong>方向控制</strong>：<br>可以定义一个变量来指示当前填充的方向（例如，0表示向右，1表示向下，2表示向左，3表示向上）。在每次填充完一行或一列后，更新方向变量，以改变填充的方向。</p></li><li><p><strong>层次处理</strong>：<br>将螺旋矩阵视为多个层次的环，从外层到内层逐层处理。每一层的处理逻辑相似，但边界和起始位置会有所不同。</p></li><li><p><strong>特殊情况处理</strong>：<br>对于奇数大小的矩阵，中心会有一个单独的元素。在算法中需要特别处理这种情况，确保中心元素被正确填充。</p></li></ol><h2 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:<br>O(n^2)</p><p>空间复杂度:<br>O(1)</p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) {</span><br><span class="line">        <span class="type">int</span> loop=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> [][]res=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop++&lt;n/<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">for</span>(j=start;j&lt;n-loop;j++){</span><br><span class="line">                res[start][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(i=start;i&lt;n-loop;i++){</span><br><span class="line">                res[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;=loop;j--){</span><br><span class="line">                res[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;=loop;i--){</span><br><span class="line">                res[i][j]=count++;</span><br><span class="line">            }</span><br><span class="line">            start++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>){</span><br><span class="line">                res[start][start]=count;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2024/03/21/redis/"/>
      <url>/2024/03/21/redis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一次更新：2024/3/21</p></blockquote><h2 id="何为Redis？"><a href="#何为Redis？" class="headerlink" title="何为Redis？"></a>何为<code>Redis</code>？</h2><p>可以理解为在内存中存储数据，适用于分布式系统；而对于单机架构，直接用变量存储则是更优的选择；</p><p><code>Redis</code>基于网络，可以把自己内存中的变量给别的主机进程使用；</p><p>与<code>MySQL</code>相比，<code>Redis</code>快，但存储空间有限；</p><p>一般使用<code>Redis</code>+<code>MySQL</code>，可以满足“二八原则”；但是这样系统的复杂度也会增加，同时，也涉及<code>Redis</code>和<code>MySQL</code>的同步问题</p><hr><h2 id="何为分布式系统？"><a href="#何为分布式系统？" class="headerlink" title="何为分布式系统？"></a>何为分布式系统？</h2><p>首先先说一下<strong>单机架构</strong>：只有一台服务器，负责所有工作（应用服务+数据库服务）。<br>而一台主机的硬件资源有限，服务器处理请求需要消耗资源，此时，想要处理大量请求，<strong>要么</strong>加硬件，<strong>要么</strong>性能测试，对症下药。<br>一台主机最终会被拓展到极限–&gt;此时，引入多台主机，即<strong>分布式系统</strong>。</p><p><strong>分布式系统中提高性能、可靠性、稳定性有哪些具体方案呢?</strong></p><ul><li><strong>应用服务器和数据库服务器分离</strong>：对于前者重点配置<code>CPU</code>和内存资源，对于后者重点配置硬盘资源。</li><li><strong>引入更多应用服务器节点，通过负载均衡器分配请求</strong>。</li><li><strong>数据库读写分离</strong>：主数据库负责写，从数据库负责读，一般是“一主多从”。</li><li><strong>缓存</strong>：将数据分为冷、热数据。缓存中放热数据，只占全量数据的一小部分（二八原则）。</li><li>数据量过大，一台服务器存不下时：使用多台主机对数据库进行拆分，“<strong>分库分表</strong>”</li><li><strong>微服务</strong>：一个复杂的服务器拆分为更多功能单一更小的服务器。<ul><li><strong>优点</strong>：1. 功能复用 2. 不同功能不同部署</li><li><strong>缺点</strong>：1. 性能下降，因为微服务间通过网络通信。缓解办法：加硬件资源 2. 系统复杂性增加。缓解办法：监控报警+维护人员。</li></ul></li></ul><hr><h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a><code>Redis</code>特性</h2><blockquote><p>整理自官网，并加入自己的理解</p></blockquote><ol><li><strong>在内存中存储数据</strong>：以<code>&lt;key,value&gt;</code>方式存储组织数据</li><li><strong>可编程性</strong>：简单交互式命令/脚本</li><li><strong>可拓展性</strong>：可用<code>C、C++、Rust</code>编写<code>Redis</code>扩展，使其支持更多地数据结构</li><li><strong>持久化</strong>：内存数据掉电会丢失，<code>Redis</code>会把数据备份到硬盘</li><li><strong>集群化</strong>： 即水平扩展，支持多个<code>Redis</code>节点，每个Redis存储一部分数据。是不是很像分库分表？</li><li><strong>高可用</strong>：冗余 “主从”</li><li><strong>快</strong> ，原因如下：</li></ol><ul><li>数据在内存中</li><li>核心功能为操作简单数据结构</li><li>使用<code>I/O</code>多路复用</li><li>使用单线程模型，减少不必要的线程之间的竞争开销<br><strong>那么问题来了，为什么用单线程模型还能快呢？</strong><br><strong>原因</strong>：多线程提高效率的前提时<code>CPU</code>密集型任务，而<code>Redis</code>不会吃很多<code>CPU</code>，因为第<code>2</code>条原因</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题-数组基础day1</title>
      <link href="/2024/03/20/suan-fa-shua-ti-shu-zu-ji-chu-day1/"/>
      <url>/2024/03/20/suan-fa-shua-ti-shu-zu-ji-chu-day1/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem-704-二分查找"><a href="#Problem-704-二分查找" class="headerlink" title="Problem: 704. 二分查找"></a>Problem: <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>二分查找，重点是边界的判断</p></blockquote><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><ol><li>第一种写法：左闭右闭区间 <code>[left, right]</code></li></ol><ul><li><p>区间定义：目标值 <code>target</code> 在区间 <code>[left, right]</code> 内。</p></li><li><p>关键点：</p><ul><li><p>循环条件：使用 <code>while (left &lt;= right)</code>，因为当 <code>left == right</code> 时，中间元素 <code>nums[middle]</code> 可能就是目标值，所以需要检查。</p></li><li><p>边界更新：</p><ul><li>如果 <code>nums[middle] &gt; target</code>，则更新 <code>right = middle - 1</code>，因为当前 <code>nums[middle]</code>不是目标值，且由于区间是左闭右闭的，所以 <code>middle</code> 不应包含在下一轮搜索的右区间中。</li><li>如果 <code>nums[middle] &lt; target</code>，则更新 <code>left = middle + 1</code>，因为当前 <code>nums[middle]</code> 不是目标值，且下一轮搜索的左区间应从 middle 的下一个位置开始。</li></ul></li></ul></li></ul><ol start="2"><li>第二种写法：左闭右开区间 <code>[left, right)</code></li></ol><ul><li><p>区间定义：目标值 <code>target</code> 在区间 <code>[left, right)</code> 内。</p></li><li><p>关键点：</p><ul><li><p>循环条件：使用 <code>while (left &lt; right)</code>，因为当 <code>left == right</code> 时，区间 <code>[left, right)</code> 内没有元素，所以不需要检查。</p></li><li><p>边界更新：</p><ul><li>如果 <code>nums[middle] &gt; target</code>，则更新 <code>right = middle</code>，因为当前 <code>nums[middle]</code> 不是目标值，且由于区间是左闭右开的，所以<code>middle</code> 不应包含在下一轮搜索的右区间中。</li><li>如果 <code>nums[middle] &lt; target</code>，则更新 <code>left = middle + 1</code>，与第一种写法相同，因为 <code>middle</code> 也不应包含在下一轮搜索的左区间中。</li></ul></li></ul></li></ul><p><strong>注意事项</strong><br>在二分查找中，<code>middle</code> 的计算通常使用 <code>int middle = left+(right - left) / 2</code>;<br>而不是 <code>int middle = (left + right) / 2</code>;<br>这是为了避免当 <code>left</code> 和 <code>right</code>都很大时，它们的和可能会导致整数溢出。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:</p><blockquote><p>O(log n)</p></blockquote><p>空间复杂度:</p><blockquote><p>O(1)</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右闭区间 [left, right]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r){</span><br><span class="line">            <span class="type">int</span> mid=(r+l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> num=nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(num==target){</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;target){</span><br><span class="line">                r=mid-<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右开区间 [left, right)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> {</span><br><span class="line">      <span class="type">int</span> l=<span class="number">0</span>,r=nums.length;</span><br><span class="line">      <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">        <span class="type">int</span> mid=(r+l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]){</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]){</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">           r=mid;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Problem-27-移除元素"><a href="#Problem-27-移除元素" class="headerlink" title="Problem: 27. 移除元素"></a>Problem: <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote><p>双指针法</p></blockquote><h2 id="解题方法-1"><a href="#解题方法-1" class="headerlink" title="解题方法"></a>解题方法</h2><ul><li>具体来说，我们使用两个指针<code>l</code>和<code>r</code>，它们都从数组的开始位置（索引为<code>0</code>）开始。其中，<code>l</code>指针用于指向下一个非<code>val</code>元素应该存放的位置，而<code>r</code>指针用于遍历整个数组。</li><li>在遍历过程中，如果<code>nums[r]</code>不等于<code>val</code>，说明当前元素是需要保留的，那么我们就把它放到<code>l</code>指针所指向的位置，并且<code>l</code>指针向前移动一位，以指向下一个非<code>val</code>元素应该存放的位置。如果<code>nums[r]</code>等于<code>val</code>，那么我们就跳过这个元素，<code>l</code>指针不动，只让<code>r</code>指针继续向前遍历。</li><li>遍历完成后，<code>l</code>指针所指向的位置就是数组中最后一个非<code>val</code>元素的下一个位置，也就是移除<code>val</code>元素后数组的新长度。因此，我们返回<code>l</code>作为结果。</li></ul><p><strong>总结</strong>： 在这个算法中，<code>l</code>和<code>r</code>指针初始时都指向数组的第一个元素。随着遍历的进行，<code>r</code>指针可能会走得比<code>l</code>指针快，因为当遇到值为<code>val</code>的元素时，<code>r</code>指针会继续向前移动，而<code>l</code>指针则保持不变。当遍历结束时，<code>l</code>指针指向的就是新数组（移除<code>val</code>后）的末尾位置。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度:</p><blockquote><p>O(n)</p></blockquote><p>空间复杂度:</p><blockquote><p>O(1)</p></blockquote><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> {</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;nums.length;r++){</span><br><span class="line">                <span class="keyword">if</span>(nums[r]!=val){</span><br><span class="line">                    nums[l]=nums[r];</span><br><span class="line">                    l++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之系统调用</title>
      <link href="/2024/03/19/cao-zuo-xi-tong-zhi-xi-tong-diao-yong/"/>
      <url>/2024/03/19/cao-zuo-xi-tong-zhi-xi-tong-diao-yong/</url>
      
        <content type="html"><![CDATA[<p>我们可以通过命令行来使用到操作系统提供的功能，那么输入一个命令行后发生了什么？下面举一个实际的<strong>例子</strong>来说明：</p><p><strong>有关操作</strong>：<br>你编写了一个<code>output.c</code>文件，该程序内容如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> * argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ECHO:%s\n"</span>,argv[<span class="number">1</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后，你在命令行输入<code>gcc -o output output.c</code></p><blockquote><p>这条命令的意思是：使用 GCC 编译器编译 output.c文件，并将编译后的可执行文件命名为 output</p></blockquote><p><strong>这时</strong>，在命令行输入 <code>./output "hello"</code><br>得到结果： <code>ECHO:hello</code></p><p>那么输入一个命令行后发生了什么才得到我们想要的<strong>结果</strong>了呢？</p><p><strong>首先</strong>，说明<strong>命令的含义</strong>：就是一段程序。<br>程序要编译，程序编译完后生成可执行文件，刚才我们已经说明。</p><p><code>./ouput</code>运行可执行文件，那么<code>“hello”</code>究竟是怎么读到的呢？<br>这就是<code>shell</code>所做的工作，<code>shell</code>的本质也是一段程序，关键代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char * argv[])</span><br><span class="line">{</span><br><span class="line">    char cmd[20];</span><br><span class="line">    while(1){</span><br><span class="line">        scanf("%s",cmd);</span><br><span class="line">        if(!fork()){exec(cmd);}</span><br><span class="line">        else wait();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>关键代码说明</strong><br><code>if (!fork())</code>：调用 <code>fork()</code> 函数创建一个子进程。<code>fork()</code> 返回一个正整数（父进程的PID）给父进程，返回0给子进程。因此，<code>!fork()</code> 的条件只在子进程中为真。</p><p><code>exec(cmd)</code>：在子进程中，调用 <code>exec</code> 函数来执行用户输入的命令。</p><p><code>else wait()</code>：在父进程中，调用 <code>wait()</code> 函数等待子进程结束。<code>wait()</code> 会阻塞父进程，直到任意一个子进程结束。</p><p>那么什么是<strong>操作系统接口</strong>呢？</p><p>就是函数，比如刚才的<code>printf</code>，而<code>printf</code>包装了一个系统调用<code>write()</code>。</p><p>所以说接口表现为函数调用，又由系统提供，所以称为系统调用,即<code>System_call</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 系统调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务之SpringCloud</title>
      <link href="/2024/03/18/wei-fu-wu-zhi-springcloud/"/>
      <url>/2024/03/18/wei-fu-wu-zhi-springcloud/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><code>Spring Cloud Alibaba</code> 是阿里开源的一套微服务开发组件，致力于提供微服务开发的一站式解决方案，核心组件有下面这些：</p><ul><li><code>Sentinel</code>：以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>Nacos</code>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Seata</code>：分布式事务解决方案。</li><li><code>OpenFeign</code>：轻量级 RESTful 的 HTTP 服务客户端，用于替代已经进入停更维护状态的 Feign（Netflix Feign）</li><li><code>Gateway</code>：用于网关服务，实现请求的转发和路由。</li><li><code>Ribbon</code>：用于客户端负载均衡，将请求分发给不同的微服务实例。</li></ul><h3 id="2-实践选择："><a href="#2-实践选择：" class="headerlink" title="2.实践选择："></a>2.实践选择：</h3><p>本次实践选用的组件如下：</p><ul><li><code>Eureka</code> 实现服务注册与发现(<code>Netflix</code>)</li><li><code>Gateway</code> 实现 <code>API</code> 网关</li><li><code>Ribbon</code> 实现负载均衡（<code>Feign</code> 内置）</li><li><code>Feign</code> 实现基于 <code>Feign</code> 的服务调用</li><li><code>Hystrix</code> 实现服务熔断（<code>Feign</code> 内置）</li><li><code>Config</code> 实现 <code>Config</code> 配置中心</li></ul><p>&lt;picture项目逻辑架构&gt;</p><h3 id="3-SpringCloud-聚合项目的创建"><a href="#3-SpringCloud-聚合项目的创建" class="headerlink" title="3.SpringCloud 聚合项目的创建"></a>3.SpringCloud 聚合项目的创建</h3><h4 id="3-1聚合项目及其作用"><a href="#3-1聚合项目及其作用" class="headerlink" title="3.1聚合项目及其作用"></a>3.1聚合项目及其作用</h4><ol><li>创建聚合项目的目的:</li></ol><ul><li>更好地管理和组织多个相关联的项目，可以统一管理它们的<strong>依赖关系</strong>，统一<strong>打包发布</strong>，方便项目的构建和部署。</li><li>聚合项目也可以提高团队协作效率，统一管理项目的<strong>版本和发布流程</strong>。</li><li>聚合项目还可以方便地进行跨项目的<strong>代码重用和共享</strong>，提高代码的<strong>复用性和可维护性</strong>。</li></ul><h4 id="3-2-聚合项目（父级项目、顶级项目）的Maven配置说明"><a href="#3-2-聚合项目（父级项目、顶级项目）的Maven配置说明" class="headerlink" title="3.2 聚合项目（父级项目、顶级项目）的Maven配置说明"></a>3.2 聚合项目（父级项目、顶级项目）的Maven配置说明</h4><p><strong>聚合项目特性</strong></p><p>聚合项目本身也是一个Maven项目，其核心在于管理和协调多个子模块。这样的设计有助于消除子模块POM中的重复配置，提升项目的可维护性。</p><p><strong>关键配置要点</strong></p><ol><li><strong>POM文件</strong>：聚合项目必须有自己的<code>pom.xml</code>文件。</li><li><strong>打包方式</strong>：聚合项目的打包方式必须是<code>pom</code>，因为它不包含任何实际代码。</li><li><strong>目录结构</strong>：聚合模块仅包含<code>pom.xml</code>文件，不包含<code>src/main/java</code>和<code>src/test/java</code>等目录。</li></ol><p><strong>引入新元素</strong></p><ul><li><strong>modules-module</strong>：用于声明聚合的子模块，每个子模块都是一个独立的项目。</li></ul><p><strong>版本一致性</strong></p><ul><li>聚合模块的版本应与被聚合的子模块版本保持一致，以确保依赖关系的一致性。</li></ul><p><strong>路径配置</strong></p><ul><li><strong>relative path</strong>：每个子模块的名称都应是当前POM文件的相对目录。</li></ul><p><strong>目录命名约定</strong></p><ul><li>为了方便定位，建议模块所在的目录与其<code>artifactId</code>保持一致。但这不是硬性要求，重要的是模块目录必须与聚合模块中声明的模块目录相匹配。</li></ul><p><strong>目录结构选择</strong></p><ul><li>聚合模块与子模块可以是父子级结构，也可以是平行结构。推荐使用平行结构，因为它有助于保持项目结构的清晰和易于维护。如果使用平行结构，需要在POM文件中相应调整目录路径配置。</li></ul><p><strong>删除子模块注意事项</strong></p><ul><li>如果从聚合项目中删除了某个子模块，务必在聚合模块的<code>pom.xml</code>文件中的<code>modules</code>选项中删除对应的子模块声明，以避免潜在的配置错误。</li></ul><h4 id="3-3实操演练"><a href="#3-3实操演练" class="headerlink" title="3.3实操演练"></a>3.3实操演练</h4><blockquote><p> 待更新…….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2024/03/17/suan-fa/"/>
      <url>/2024/03/17/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS-宽度优先搜索"><a href="#BFS-宽度优先搜索" class="headerlink" title="BFS 宽度优先搜索"></a>BFS 宽度优先搜索</h1><h4 id="1-基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾"><a href="#1-基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾" class="headerlink" title="1. 基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾"></a>1. 基本思想：利用队列，每次取出队头元素，将拓展出的所有元素放到队尾</h4><blockquote><p>理解拓展：目前做的2道题-迷宫有关，拓展的是队头的上下左右（2维迷宫）/向北、向南、向东、向西、向上、向下（3维迷宫）</p></blockquote><blockquote><p>BFS最先输出的肯定是最短路径，因为是按宽度搜索的；求最短路径的题可以想想宽搜</p></blockquote><h4 id="2-模板如下："><a href="#2-模板如下：" class="headerlink" title="2. 模板如下："></a>2. 模板如下：</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 判重数组st[]  //入队时判重</span><br><span class="line">2. queue</span><br><span class="line">    queue&lt;-初始状态</span><br><span class="line">    while(queue非空)</span><br><span class="line">    {</span><br><span class="line">        t&lt;-队头 //队头出队</span><br><span class="line">        for(拓展t)</span><br><span class="line">        {</span><br><span class="line">            v&lt;-新节点</span><br><span class="line">            if(!st[v])</span><br><span class="line">            {</span><br><span class="line">                v-&gt;队尾</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="3-具体习题"><a href="#3-具体习题" class="headerlink" title="3. 具体习题"></a>3. 具体习题</h4><h5 id="3-1-献给阿尔吉侬的花束-二维"><a href="#3-1-献给阿尔吉侬的花束-二维" class="headerlink" title="3.1 献给阿尔吉侬的花束(二维)"></a>3.1 <a href="https://www.acwing.com/problem/content/1103/">献给阿尔吉侬的花束(二维)</a></h5><p>具体代码实现如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"></span><br><span class="line">const int N = 210;</span><br><span class="line"></span><br><span class="line">char a[N][N];</span><br><span class="line">int dis[N][N];</span><br><span class="line"></span><br><span class="line">void bfs(PII start)</span><br><span class="line">{</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.push(start);//队头队，对应步骤1</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        PII u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int dx[4] = {-1, 0, 1, 0};</span><br><span class="line">        int dy[4] = {0, 1, 0 ,-1};</span><br><span class="line">        for(int i = 0; i &lt; 4; i++)//遍历四个方向，对应步骤2</span><br><span class="line">        {</span><br><span class="line">            int x = u.first + dx[i];</span><br><span class="line">            int y = u.second + dy[i];</span><br><span class="line"></span><br><span class="line">            if(a[x][y] == '#') continue;//如果是'#',不做任何处理</span><br><span class="line">            if(a[x][y] == '.')//如果是 '.'，更新对应内容</span><br><span class="line">            {</span><br><span class="line">                dis[x][y] = dis[u.first][u.second] + 1;</span><br><span class="line">                a[x][y] = '#';</span><br><span class="line">                q.push({x, y});</span><br><span class="line">            }</span><br><span class="line">            if(a[x][y] == 'E')//如果是'E'，找到了，输出</span><br><span class="line">            {</span><br><span class="line">                cout &lt;&lt; dis[u.first][u.second] + 1 &lt;&lt; endl;</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; "oop!" &lt;&lt; endl;//没有找到</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t--)</span><br><span class="line">    {</span><br><span class="line">        memset(a, '#', sizeof(a));//初始化地图，各个点都是墙。</span><br><span class="line">        memset(dis, 0, sizeof(dis));//初始化dis</span><br><span class="line">        int n,m;</span><br><span class="line">        PII start;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)//从第一行存储地图，因为四周都是墙，bfs时，可以不做越界判断</span><br><span class="line">        {</span><br><span class="line">            for(int j = 1; j &lt;= m; j++)//从第一；列存储地图，因为四周都是墙，bfs时，可以不做越界判断</span><br><span class="line">            {</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                if(a[i][j] == 'S')//记录下起点位置。</span><br><span class="line">                    start.first = i, start.second = j, a[i][j] = '#';</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        bfs(start);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="3-2-地牢大师-三维"><a href="#3-2-地牢大师-三维" class="headerlink" title="3.2 地牢大师(三维)"></a>3.2 <a href="https://www.acwing.com/problem/content/1098/">地牢大师(三维)</a></h5><p>仿照刚才二维的题，给出具体代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">{</span><br><span class="line">    int x,y,z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">char m[N][N][N];//地图</span><br><span class="line">int dis[N][N][N];</span><br><span class="line">int l,r,c;</span><br><span class="line">int dx[6] = {-1, 0, 1, 0, 0, 0}, dy[6] = {0, 1, 0, -1, 0, 0}, dz[6] = {0, 0, 0, 0, 1, -1};</span><br><span class="line"></span><br><span class="line">int bfs(Point start)</span><br><span class="line">{</span><br><span class="line">    queue&lt;Point&gt; q;</span><br><span class="line">    </span><br><span class="line">    q.push(start);</span><br><span class="line">    </span><br><span class="line">    while(!q.empty())</span><br><span class="line">    {</span><br><span class="line">        Point t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        for(int i=0;i&lt;6;i++)</span><br><span class="line">        {</span><br><span class="line">            int x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];</span><br><span class="line">            if(m[x][y][z]=='#')continue;</span><br><span class="line">            if(m[x][y][z]=='.')</span><br><span class="line">            {</span><br><span class="line">                dis[x][y][z]=dis[t.x][t.y][t.z]+1;</span><br><span class="line">                m[x][y][z]='#';</span><br><span class="line">                q.push({x,y,z});</span><br><span class="line">            }</span><br><span class="line">            if(m[x][y][z]=='E')</span><br><span class="line">            {</span><br><span class="line">                return dis[t.x][t.y][t.z]+1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return -1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    while(scanf("%d%d%d",&amp;l,&amp;r,&amp;c),l||r||c)</span><br><span class="line">    {</span><br><span class="line">        memset(m,'#',sizeof(m));</span><br><span class="line">        memset(dis,0,sizeof(dis));</span><br><span class="line">        Point start,end;</span><br><span class="line">        for(int i=1;i&lt;=l;i++)</span><br><span class="line">        {</span><br><span class="line">            for(int j=1;j&lt;=r;j++)</span><br><span class="line">            {</span><br><span class="line">                for(int k=1;k&lt;=c;k++)</span><br><span class="line">                {</span><br><span class="line">                    cin&gt;&gt;m[i][j][k];</span><br><span class="line">                    if(m[i][j][k]=='S')start={i,j,k};</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        int distance=bfs(start);</span><br><span class="line">        if(distance==-1)puts("Trapped!");</span><br><span class="line">        else printf("Escaped in %d minute(s).\n",distance);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>其实可以看出很强的规律性，这两道题的做法几乎可以一模一样；等我再做几道题找找规律</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复盘</title>
      <link href="/2024/03/15/fu-pan/"/>
      <url>/2024/03/15/fu-pan/</url>
      
        <content type="html"><![CDATA[<h3 id="2024-3-15"><a href="#2024-3-15" class="headerlink" title="2024/3/15"></a>2024/3/15</h3><blockquote><p>开学将近两周了，今天起，每日记录自己的收获，学习笔记心得啥的，多动脑多记录多实践，现在是2024/3/15 23:51，开始记录，也是对自己的检讨和复盘，即使调整学习状态吧</p></blockquote><p><strong>今日收获</strong></p><ol><li><code>leetcode</code>刷了7道题</li><li>八股计网看完了，操作系统看了一半</li></ol><p><code>今天没学太多，上午起来后就去上课了，晚上开始就一直焦虑摆烂刷帖子，有效学习就在下午，满打满算也就学了3个小时。</code><br><code>又开始焦虑了，总是认为只能兼顾一头，实际上时间是很够的，多学习多思考，我的学习能力不差的，焦虑的时候不看帖子群聊啥的了，专注提升自己的技术吧，多多实践</code></p><p><code>加油</code></p><h3 id="2024-3-17"><a href="#2024-3-17" class="headerlink" title="2024/3/17"></a>2024/3/17</h3><p><strong>今日收获</strong></p><ol><li>双指针算法，`BFS算法，图论算法各一题，找时间写博客总结</li><li>数学学习，多背背结论，这是为了站在高起点</li><li><code>SpringCloud</code>学习，搭建基础项目结构</li></ol><blockquote><p>调整为周计划待办的方式记录学习</p></blockquote><h3 id="2024-3-18"><a href="#2024-3-18" class="headerlink" title="2024/3/18"></a>2024/3/18</h3><p><strong>本周待办</strong></p><ol><li>70道leetcode</li><li>八股 保质</li><li>OS实验</li><li>高数一元微分学</li><li>每日单词</li><li>微服务项目，不确定难度，这周摸索一下，不要求做的太多</li><li>…</li></ol>]]></content>
      
      
      <categories>
          
          <category> 复盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心灵对话 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
